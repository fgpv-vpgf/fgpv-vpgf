<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ui/toc/toc.service.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ui/toc/toc.service.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module tocService
 * @memberof app.ui
 *
 * @description
 * The `tocService` service provides bindable layer data to the `TocController`'s template.
 *
 *
 */
angular
    .module('app.ui')
    .factory('tocService', tocService);

function tocService($q, $rootScope, $mdToast, $translate, $timeout, referenceService, common, stateManager, graphicsService,
    geoService, metadataService, errorService, LegendBlock, configService, legendService, layerRegistry, Geo, events) {

    const service = {
        // method called by the options and flags set on the layer item
        actions: {
            toggleLayerTablePanel
        },

        toggleSettings,
        toggleMetadata,
        toggleLayerTablePanel,

        removeLayer,
        reloadLayer,

        validMetadata: false
    };

    const ref = {
        selecteLegendBlockLog: {}
    };

    // name mapping between true panel names and their short names
    const panelSwitch = {
        table: {
            panel: 'tableFulldata',
            action: toggleLayerTablePanel
        },
        metadata: {
            panel: 'sideMetadata',
            action: toggleMetadata
        },
        settings: {
            panel: 'sideSettings',
            action: toggleSettings
        }
    };

    let errorToast;

    // set state change watches on metadata, settings and table panel
    watchPanelState('sideMetadata', 'metadata');
    watchPanelState('sideSettings', 'settings');
    watchPanelState('tableFulldata', 'table');

    // wire in a hook to any map for removing a layer. this makes it available on the API
    events.$on(events.rvMapLoaded, () => {
        configService.getSync.map.instance.removeApiLayer = (id, index) => {
            const legendBlocks = configService.getSync.map.legendBlocks;
            let layerToRemove = legendBlocks.walk(l => l.layerRecordId === id ? l : null).filter(a => a);

            // TODO: fix this, will only remove 1 instance from legend if there are multiple legend blocks referencing it  ?
            if (layerToRemove.length > 0) {
                if (index !== undefined) {
                    // in cases of dynamic, if index specified, remove only that child, otherwise we choose to remove entire group below
                    layerToRemove = layerToRemove.find(l => l.itemIndex === index);
                } else {
                    // removing the first instance, whether it be the legend group or node
                    layerToRemove = layerToRemove[0];
                }

                if (layerToRemove) {
                    service.removeLayer(layerToRemove);
                }
            } else {
                // layer is not in legend (or does not exist), try simply removing layer record
                layerRegistry.removeLayerRecord(id);
            }
        }
    });

    return service;

    /**
     * This will reload the layer records referenced by the specified legend block and all other legend blocks attached to that record;
     * will also reload all controlled layer records.
     *
     * This will close and reopen a panel if it is connected with the layer record being reloaded
     * Otherwise, any open panel will be closed
     * @function reloadLayer
     * @param {LegendBlock} legendBlock legend block to be reloaded
     */
    function reloadLayer(legendBlock) {
        // get table configuration and check if static field were used. If so, table can't be remove and flag need to stay
        const tableConfig = configService.getSync.map.layerRecords.find(item =>
            item.config.id === legendBlock.layerRecordId).initialConfig.table;

        // update filter flag
        if (tableConfig) {
            legendBlock.filter = tableConfig.applied;
        }

        // search for open panels from the top-most parent (excluding the root level)
        let topLevelBlock = legendBlock;
        while (topLevelBlock.parent.parent) {
            topLevelBlock = topLevelBlock.parent;
        }

        const openPanel = _findOpenPanel(panelSwitch, topLevelBlock);
        if (openPanel) {
            const panel = panelSwitch[openPanel.name].panel;
            stateManager.setActive({ [panel]: false });
        } else {    // open panel not being reloaded, close any open panel
            stateManager.setActive({ tableFulldata: false } , { sideMetadata: false }, { sideSettings: false });
        }

        legendService.reloadBoundLegendBlocks(legendBlock.layerRecordId, openPanel).then(block => {
            if (openPanel) {
                const findBlock = block
                    .walk(entry =>
                        entry.id === openPanel.requester.id ?
                            entry : null)
                    .filter(a => a)[0];

                if (findBlock) {        // open panel not reloaded, close any open panel
                    stateManager.setActive({ tableFulldata: false }, { sideMetadata: false }, { sideSettings: false });
                    return;
                }

                // for the table, panel data is columns, rows, etc. instead of the actual entry
                // thus, we need to take the legend entry in those cases
                // for settings and metadata, if data exists it is the correct entry
                const node = openPanel.name !== 'table' &amp;&amp; openPanel.data ?
                    openPanel.data :
                    openPanel.requester.legendEntry ?
                        openPanel.requester.legendEntry : legendBlock;

                // find reloaded legend block
                // if there are multiple instances of the same layer, reloading any record other than the first one will still
                // return the first legend block and open the panel for that one instead (they are identical though)
                legendBlock = block
                    .walk(entry =>
                        (node.parentLayerType ===  Geo.Layer.Types.ESRI_DYNAMIC ? entry.blockConfig.entryIndex === node.blockConfig.entryIndex :
                        entry.layerRecordId === node.layerRecordId) ?
                            entry : null)
                    .filter(a => a &amp;&amp; a._isDynamicRoot === node._isDynamicRoot)[0]; // filter out hidden dynamic root if any

                if (openPanel.name === 'table') {
                    toggleLayerTablePanel(legendBlock);
                } else if (openPanel.name === 'settings') {
                    toggleSettings(legendBlock);
                } else if (openPanel.name === 'metadata') {
                    toggleMetadata(legendBlock);
                }
            }
        }, (layerName) => {
            console.error('Failed to reload layer:', layerName);
        });
    }

    /**
     * Removes the provided legend block from the layer selector, hides the corresponding layer, displays a toast
     * notification give the user a chance to undo.
     * This will also close an open panel related to the layer being remove and restore this panel if the removal is cancelled.
     *
     * // TODO: come up with a better name; this one is not descriptive enough;
     * @function removeLayer
     * @param  {LegendBlock} legendBlock legend block to be remove from the layer selector
     */
    function removeLayer(legendBlock) {
        let resolve, reject, openPanelName;

        // legendBlock is the only child in the group, remove parent instead of just child
        if (legendBlock.parent &amp;&amp; legendBlock.parent.entries.length === 1) {
            removeLayer(legendBlock.parent);
            return;
            // legendBlock has no parent, so we are at the top most level
            // this block has one entry which is the only one currently in the legend, remove that entry
        } else if (!legendBlock.parent) {
            openPanelName = _findOpenPanel(panelSwitch, legendBlock);
            [resolve, reject] = legendService.removeLegendBlock(legendBlock.entries[0]);
            // remove the legendBlock normally since it has other siblings
        } else {
            // each legend block can have only one panel open at a time; find its name;
            openPanelName = _findOpenPanel(panelSwitch, legendBlock);
            [resolve, reject] = legendService.removeLegendBlock(legendBlock);
        }

        if (openPanelName) {
            stateManager.setActive({ [panelSwitch[openPanelName.name].panel]: false });
        }

        // let the layer know that the block has been deselected due to removal
        legendBlock.isSelected = false;

        // create notification toast
        const undoToast = $mdToast.simple()
            .textContent($translate.instant('toc.label.state.remove'))
            .action($translate.instant('toc.label.action.remove'))
            .parent(referenceService.panes.toc)
            .position('bottom rv-flex');

        // promise resolves with 'ok' when user clicks 'undo'
        $mdToast.show(undoToast)
            .then(response =>
                response === 'ok' ? _restoreLegendBlock() : resolve());

        console.log(stateManager.display);

        function _restoreLegendBlock() {
            reject();
        }
    }

    /**
    * Find any open panels matching the legendBlock
    * @private
    * @function _findOpenPanel
    * @param {Object} panelSwitch name mapping between true panel names and their short names
    * @param {LegendBlock} legendBlock legend block to be searched for open panel
    * @return {Object} requester, data and name of open panel (if any)
    */
    function _findOpenPanel(panelSwitch, legendBlock) {
        return Object.keys(panelSwitch)
            .map(panelName => {
                const panelDisplay = stateManager.display[panelName];
                if (panelDisplay.requester &amp;&amp; panelDisplay.requester.id === legendBlock.id) {
                    return {
                        requester: panelDisplay.requester,
                        data: panelDisplay.data,
                        name: panelName
                    };
                }
                else if (panelDisplay.requester &amp;&amp; legendBlock.entries) {
                    // walk through the children of the current block to see if there's an open panel being removed
                    return legendBlock
                        .walk(lb => lb.id === panelDisplay.requester.id ? lb.id : null)
                        .filter(a => a)[0] ? {
                            requester: panelDisplay.requester,
                            data: panelDisplay.data,
                            name: panelName
                        } : null;
                } else {
                    return null;
                }
            })
            .filter(a => a !== null)[0] || null;
    }

    // TODO: rename to something like `setVisibility` to make it clearer what this does
    // if 'value' is not specified, toggle
    function toggleVisiblity(tocEntry, value) {
        RV.logger.log('tocService', `toggle visiblity of layer with name ${tocEntry.name}`);
        tocEntry.setVisibility(value);

        // hide bounding box only when visibility is hidden
        // TODO: move to the LayerRecord class when LayerRecord is moved into geoapi
        if (tocEntry.options.boundingBox &amp;&amp; !tocEntry.options.visibility.value) {
            tocEntry.options.boundingBox.value = false;
            geoService.setBboxState(tocEntry, false);
        }
    }

    /**
    * Zoom to layer visibility scale and set layer visible
    * @private
    * @function zoomLayerScale
    * @param {Object} entry layer object to zoom to scale to.
    */
    function zoomLayerScale(entry) {
        // zoom to layer visibility scale
        geoService.zoomToScale(entry, entry.options.offscale.value);

        // set the layer visible
        toggleVisiblity(entry, true);
    }

    /**
    * Zoom to bounding box of a layer (wrapper function to the same function in layerRegistry)
    * @function zoomToBoundary
    * @param {Object} legendEntry layer entry in the legend
    */
    function zoomToBoundary(legendEntry) {
        geoService.zoomToBoundary(legendEntry.id);
    }

    /**
     * Opens settings panel with settings from the provided legendBlock object.
     * @function toggleSettings
     * @param  {LegendBlock} legendBlock legendBlock object whose settings should be opened.
     */
    function toggleSettings(legendBlock) {
        const requester = {
            id: legendBlock.id,
            name: legendBlock.name
        };

        const panelToClose = {
            table: false
        };

        stateManager
            .setActive(panelToClose)
            .then(() => stateManager.toggleDisplayPanel('sideSettings', legendBlock, requester));
    }

    /**
     * Opens table panel with data from the provided layer object (debounce).
     *
     * @function toggleLayerTablePanel
     * @param  {Object} entry legend block object whose data should be displayed.
     * @private
     */
    function debToggleLayerTablePanel(entry) {
        const requester = {
            id: entry.id,
            name: entry.name,
            layerId: (entry.master ? entry.master : entry).id,
            legendEntry: entry
        };

        const layerRecord = geoService.layers[requester.layerId];
        const dataPromise = layerRecord.getAttributes(entry.featureIdx)
            .then(attributes => {
                const rvSymbolColumnName = 'rvSymbol';

                // TODO: formatLayerAttributes function should figure out icon and store it in the attribute bundle
                // ideally, this should go into the `formatAttributes` function in layer-record.class, but we are trying to keep as loosely bound as possible to be moved later to geoApi and this uses geoService.retrieveSymbol
                // add symbol as the first column
                // check if the symbol column already exists
                if (!attributes.columns.find(({ data }) => data === rvSymbolColumnName)) {
                    attributes.rows.forEach(row => {
                        // reset href to solve problem in Safari with svg not rendered
                        row.rvSymbol =
                            graphicsService.setSvgHref(geoService.retrieveSymbol(row, attributes.renderer));
                        row.rvInteractive = '';
                    });

                    // add a column for interactive actions (detail and zoom)
                    // do not add it inside an existing field because table will not work properly and because of https://github.com/fgpv-vpgf/fgpv-vpgf/issues/1631
                    attributes.columns.unshift({
                        data: 'rvInteractive',
                        title: '',
                        orderable: false,
                        render: '',
                        width: '40px' // for datatables
                    });

                    // add a column for symbols
                    attributes.columns.unshift({
                        data: rvSymbolColumnName,
                        title: '',
                        orderable: false,
                        render: data => `&lt;div class="rv-wrapper rv-symbol">${data}&lt;/div>`,
                        width: '20px' // for datatables
                    });
                }

                return {
                    data: attributes,
                    isLoaded: false
                };
            });

        stateManager.setActive({
            other: false
        });
        stateManager
            .setActive({
                side: false
            })
            .then(() => {
                if (errorToast) {
                    errorService.remove();
                }
                return stateManager.toggleDisplayPanel('tableFulldata', dataPromise, requester, 0);
            })
            .catch(() => {
                errorToast = errorService.display($translate.instant('toc.error.resource.loadfailed'),
                    referenceService.panes.filter);
            });
    }


    function toggleLayerTablePanel(legendBlock) {
        const requester = {
            id: legendBlock.id,
            name: legendBlock.name,
            error: false,
            layerId: legendBlock.id, //(entry.master ? entry.master : entry).id,
            legendEntry: legendBlock
        };

        // const layerRecord = geoService.layers[requester.layerId];
        const dataPromise = legendBlock.formattedData
            .then(attributes => common.$timeout(() => attributes), 1000)
            .then(attributes => {
                const rvSymbolColumnName = 'rvSymbol';

                // TODO: formatLayerAttributes function should figure out icon and store it in the attribute bundle
                // ideally, this should go into the `formatAttributes` function in layer-record.class, but we are trying to keep as loosely bound as possible to be moved later to geoApi and this uses geoService.retrieveSymbol
                // add symbol as the first column
                // check if the symbol column already exists
                if (!attributes.columns.find(({ data }) => data === rvSymbolColumnName)) {

                    attributes.rows.forEach(row => {
                        legendBlock.getSymbol(row).then(symbol => { row.rvSymbol = symbol; });
                        row.rvInteractive = '';
                    });

                    // add filters attributes needed by every columns
                    attributes.columns.forEach(columns => {
                        columns.name = columns.data; // add name so we can get column from datatables (https://datatables.net/reference/type/column-selector)
                        columns.display = true;
                        columns.sort = 'none'; // can be none, asc or desc (values use by datatable)
                        columns.filter = { };
                        columns.width = '';
                        columns.init = false;
                        columns.position = -1; // use to synchronize columns when reorder
                    });

                    // add a column for interactive actions (detail and zoom)
                    // do not add it inside an existing field because filters will not work properly and because of https://github.com/fgpv-vpgf/fgpv-vpgf/issues/1631
                    attributes.columns.unshift({
                        data: 'rvInteractive',
                        title: '',
                        orderable: false,
                        render: '',
                        width: '40px', // for datatables
                        position: 1, // for datatables
                        className: 'rv-filter-noexport' // do not show when datatble export or print
                    });

                    // add a column for symbols
                    attributes.columns.unshift({
                        data: rvSymbolColumnName,
                        title: '',
                        orderable: false,
                        render: data => `&lt;div class="rv-wrapper rv-symbol">${data}&lt;/div>`,
                        width: '20px', // for datatables
                        position: 0, // for datatables
                        className: 'rv-filter-noexport' // do not show when datatble export or print

                    });
                }

                // add filters informations (use by filters to keep info on table so it persist when we change table)
                if (typeof attributes.filter === 'undefined') {
                    attributes.filter =  {
                        globalSearch: '',
                        isApplied: true,
                        isActive: false,
                        isMapFiltered: false,
                        isInit: false,
                        isOpen: true
                    };
                }

                return {
                    data: attributes,
                    isLoaded: false
                };
            });

        stateManager.setActive({
            other: false
        });
        stateManager
            .setActive({
                side: false
            })
            .then(() => {
                if (errorToast) {
                    errorService.remove();
                }
                return stateManager.toggleDisplayPanel('tableFulldata', dataPromise, requester, 0);
            })
            .catch(error => {
                // do not show error message if loading was aborted
                if (error.message === 'ABORTED') {
                    return ;
                }

                requester.error = true; // this will hide the table loading splash

                errorToast = errorService.display({
                    textContent: $translate.instant('toc.error.resource.loadfailed'),
                    parent: referenceService.panes.filter
                });
            });
    }

    /**
     * Opens metadata panel with data from the provided layer object.
     * @function toggleMetadata
     * @param  {Object} legendBlock layer object whose data should be displayed.
     * @param  {Bool | undefined} value of the panel
     *         {state = true|undefined => pane visible,
     *          state = false => pane not visible}.
     */
    function toggleMetadata(legendBlock, value = true) {

        const requester = {
            id: legendBlock.id,
            name: legendBlock.name
        };

        const panelToClose = {
            table: false
        };

        const dataPromise = $q((resolve, reject) => {
            metadataService.loadFromURL(legendBlock.metadataUrl).then(mdata => {
                const metadataPackage = {
                    metadata: mdata,
                    metadataUrl: legendBlock.metadataUrl,
                    catalogueUrl: legendBlock.catalogueUrl
                };

                service.validMetadata = true;
                referenceService.panes.metadata.find('md-toast').remove();      // remove any lingering toast message from before

                resolve(metadataPackage);

            }).catch(error => {
                service.validMetadata = false;
                referenceService.panes.metadata.find('rv-metadata-content').empty();        // empty the panels contents

                errorService.display({
                    textContent: $translate.instant('toc.error.resource.loadfailed'),
                    parent: referenceService.panes.metadata
                });

                // display manager will stop the progress bar when datapromise is rejected
                reject(error);
            });
        });

        stateManager
            .setActive(panelToClose)
            .then(() => stateManager.toggleDisplayPanel('sideMetadata', dataPromise, requester));

    }

    /**
     * Sets a watch on StateManager for layer data panels. When the requester is changed, calls setTocEntrySelectedState to dehighlight layer options and checks the state of the layer item itself (selected / not selected).
     *
     * @function watchPanelState
     * @param  {String} panelName    name of the panel to watch as specified in the stateManager
     * @param  {String} displayName type of the display data (layer toggle name: 'settings', 'metadata', 'table')
     */
    function watchPanelState(panelName, displayName) {
        // clear display on metadata, settings, and table panels when closed
        $rootScope.$on('stateChangeComplete', (event, name, property, value) => {
            if (property === 'active' &amp;&amp; name === panelName &amp;&amp; value === false) {
                stateManager.clearDisplayPanel(panelName);
            }
        });

        $rootScope.$watch(() => stateManager.display[displayName].requester, (newRequester, oldRequester) => {
            if (newRequester !== null) {
                // deselect layer from the old requester if layer ids don't match
                if (oldRequester !== null &amp;&amp; oldRequester.id !== newRequester.id) {
                    setTocEntrySelectedState(oldRequester.id, false);
                }

                // select the new layer
                setTocEntrySelectedState(newRequester.id);
            } else if (oldRequester !== null) {
                // deselect the old layer since the panel is closed as the newRequester is null
                setTocEntrySelectedState(oldRequester.id, false);
            }
        });
    }

    /**
     * Sets selected state of the toc entry with the specified id to the specified value
     * @function setTocEntrySelectedState
     * @param {Stromg} id    toc entry id; it can be different from a layer id (sublayers of a dynamic layer will have generated ids)
     * @param {Boolean} value defaults to true;
     */
    function setTocEntrySelectedState(id, value = true) {
        const legendBlocks = configService.getSync.map.legendBlocks;

        const block = legendBlocks
            .walk(lb => lb.id === id ? lb : null)
            .filter(a => a)[0];

        // there should always be a block with the provided id, but check anyway in case it was remove or something
        if (!block) {
            return;
        }

        // toc entry is considered selected if its metadata, settings, or data panel is opened;
        // when switching between panels (opening metadata when settings is already open), events may happen out of order
        // to ensure a toc entry is not deselected untimely, keep count of open/close events
        ref.selecteLegendBlockLog[id] = (ref.selecteLegendBlockLog[id] || 0) + (value ? 1 : -1);
        block.isSelected = ref.selecteLegendBlockLog[id] > 0;
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="app.common.module_displayManager.html">displayManager</a></li><li><a href="app.common.module_stateManager.html">stateManager</a></li><li><a href="app.core.module_common.html">common</a></li><li><a href="app.core.module_ConfigObject.html">ConfigObject</a></li><li><a href="app.core.module_configService.html">configService</a></li><li><a href="app.geo.module_gapiService.html">gapiService</a></li><li><a href="app.geo.module_Geo.html">Geo</a></li><li><a href="app.geo.module_geoSearch.html">geoSearch</a></li><li><a href="app.geo.module_geoService.html">geoService</a></li><li><a href="app.geo.module_identifyService.html">identifyService</a></li><li><a href="app.geo.module_LayerBlueprintFactory.html">LayerBlueprintFactory</a></li><li><a href="app.geo.module_layerRegistry.html">layerRegistry</a></li><li><a href="app.geo.module_LayerSourceInfo.html">LayerSourceInfo</a></li><li><a href="app.geo.module_LegendBlock.html">LegendBlock</a></li><li><a href="app.geo.module_LegendElementFactory.html">LegendElementFactory</a></li><li><a href="app.geo.module_legendService.html">legendService</a></li><li><a href="app.geo.module_locateService.html">locateService</a></li><li><a href="app.geo.module_mapService.html">mapService</a></li><li><a href="app.geo.module_mapToolService.html">mapToolService</a></li><li><a href="app.geo.module_metadataService.html">metadataService</a></li><li><a href="app.geo.module_rvInitMap.html">rvInitMap</a></li><li><a href="app.geo.module_rvOverviewToggle.html">rvOverviewToggle</a></li><li><a href="app.layout.module_animationService.html">animationService</a></li><li><a href="app.layout.module_layoutService.html">layoutService</a></li><li><a href="app.layout.module_referenceService.html">referenceService</a></li><li><a href="app.layout.module_rvShell.html">rvShell</a></li><li><a href="app.module_core.html">core</a></li><li><a href="app.module_ui.html">ui</a></li><li><a href="app.ui.module_basemapService.html">basemapService</a></li><li><a href="app.ui.module_detailService.html">detailService</a></li><li><a href="app.ui.module_errorService.html">errorService</a></li><li><a href="app.ui.module_ExportComponent.html">ExportComponent</a></li><li><a href="app.ui.module_exportComponentsService.html">exportComponentsService</a></li><li><a href="app.ui.module_exportGenerators.html">exportGenerators</a></li><li><a href="app.ui.module_ExportSize.html">ExportSize</a></li><li><a href="app.ui.module_exportSizesService.html">exportSizesService</a></li><li><a href="app.ui.module_fullScreenService.html">fullScreenService</a></li><li><a href="app.ui.module_geosearchFiltersService.html">geosearchFiltersService</a></li><li><a href="app.ui.module_geosearchService.html">geosearchService</a></li><li><a href="app.ui.module_helpService.html">helpService</a></li><li><a href="app.ui.module_highlightFilter.html">highlightFilter</a></li><li><a href="app.ui.module_layerSource.html">layerSource</a></li><li><a href="app.ui.module_mapNavigationService.html">mapNavigationService</a></li><li><a href="app.ui.module_rvAppbar.html">rvAppbar</a></li><li><a href="app.ui.module_rvBasemap.html">rvBasemap</a></li><li><a href="app.ui.module_rvBasemapItem.html">rvBasemapItem</a></li><li><a href="app.ui.module_rvContentPane.html">rvContentPane</a></li><li><a href="app.ui.module_rvDetails.html">rvDetails</a></li><li><a href="app.ui.module_rvDetailsContent.html">rvDetailsContent</a></li><li><a href="app.ui.module_rvDetailsHeader.html">rvDetailsHeader</a></li><li><a href="app.ui.module_rvDetailsRecordEsrifeature.html">rvDetailsRecordEsrifeature</a></li><li><a href="app.ui.module_rvDetailsRecordEsrifeatureItem.html">rvDetailsRecordEsrifeatureItem</a></li><li><a href="app.ui.module_rvDetailsRecordHtml.html">rvDetailsRecordHtml</a></li><li><a href="app.ui.module_rvDetailsRecordText.html">rvDetailsRecordText</a></li><li><a href="app.ui.module_rvDetectScrollbar.html">rvDetectScrollbar</a></li><li><a href="app.ui.module_rvDragula.html">rvDragula</a></li><li><a href="app.ui.module_rvExportCustomSize.html">rvExportCustomSize</a></li><li><a href="app.ui.module_rvGeosearch.html">rvGeosearch</a></li><li><a href="app.ui.module_rvGeosearchBar.html">rvGeosearchBar</a></li><li><a href="app.ui.module_rvGeosearchBottomFilters.html">rvGeosearchBottomFilters</a></li><li><a href="app.ui.module_rvGeosearchTopFilters.html">rvGeosearchTopFilters</a></li><li><a href="app.ui.module_rvHelpOverlay.html">rvHelpOverlay</a></li><li><a href="app.ui.module_rvHelpSearch.html">rvHelpSearch</a></li><li><a href="app.ui.module_rvLayerListSlider.html">rvLayerListSlider</a></li><li><a href="app.ui.module_rvLegendBlock.html">rvLegendBlock</a></li><li><a href="app.ui.module_rvLoaderFile.html">rvLoaderFile</a></li><li><a href="app.ui.module_rvLoaderMenu.html">rvLoaderMenu</a></li><li><a href="app.ui.module_rvMapnav.html">rvMapnav</a></li><li><a href="app.ui.module_rvMapnavButton.html">rvMapnavButton</a></li><li><a href="app.ui.module_rvMenuLink.html">rvMenuLink</a></li><li><a href="app.ui.module_rvMetadataContent.html">rvMetadataContent</a></li><li><a href="app.ui.module_rvMetadataExpand.html">rvMetadataExpand</a></li><li><a href="app.ui.module_rvMetadataPanel.html">rvMetadataPanel</a></li><li><a href="app.ui.module_rvMorph.html">rvMorph</a></li><li><a href="app.ui.module_rvPlugSlide.html">rvPlugSlide</a></li><li><a href="app.ui.module_rvReverse.html">rvReverse</a></li><li><a href="app.ui.module_rvSettings.html">rvSettings</a></li><li><a href="app.ui.module_rvSettingsContent.html">rvSettingsContent</a></li><li><a href="app.ui.module_rvSidenav.html">rvSidenav</a></li><li><a href="app.ui.module_rvStepperItem.html">rvStepperItem</a></li><li><a href="app.ui.module_rvSymbologyStack.html">rvSymbologyStack</a></li><li><a href="app.ui.module_rvTableDefault.html">rvTableDefault</a></li><li><a href="app.ui.module_rvTableDefaultMenu.html">rvTableDefaultMenu</a></li><li><a href="app.ui.module_rvTableDefinition.html">rvTableDefinition</a></li><li><a href="app.ui.module_rvTableNumberOnly.html">rvTableNumberOnly</a></li><li><a href="app.ui.module_rvTablePanel.html">rvTablePanel</a></li><li><a href="app.ui.module_rvTableSearch.html">rvTableSearch</a></li><li><a href="app.ui.module_rvTableSettingCluster.html">rvTableSettingCluster</a></li><li><a href="app.ui.module_rvTableSettingPanel.html">rvTableSettingPanel</a></li><li><a href="app.ui.module_rvToc.html">rvToc</a></li><li><a href="app.ui.module_rvTocEntryControl.html">rvTocEntryControl</a></li><li><a href="app.ui.module_rvTocExpandMenu.html">rvTocExpandMenu</a></li><li><a href="app.ui.module_rvTocVisibilityMenu.html">rvTocVisibilityMenu</a></li><li><a href="app.ui.module_rvToggleSlide.html">rvToggleSlide</a></li><li><a href="app.ui.module_rvToolbox.html">rvToolbox</a></li><li><a href="app.ui.module_rvTooltip.html">rvTooltip</a></li><li><a href="app.ui.module_rvTruncate.html">rvTruncate</a></li><li><a href="app.ui.module_sideNavigationService.html">sideNavigationService</a></li><li><a href="app.ui.module_StepperFactory.html">StepperFactory</a></li><li><a href="app.ui.module_SymbologyStack.html">SymbologyStack</a></li><li><a href="app.ui.module_tableService.html">tableService</a></li><li><a href="app.ui.module_tocService.html">tocService</a></li><li><a href="app.ui.module_tooltipService.html">tooltipService</a></li><li><a href="material.components.button.module_MdButtonDirectiveDecorator.html">MdButtonDirectiveDecorator</a></li><li><a href="material.components.dialog.module_$mdDialog.html">$mdDialog</a></li><li><a href="material.components.icon.module_mdIconDirectiveDecorator.html">mdIconDirectiveDecorator</a></li><li><a href="material.components.menu.module_mdMenuDirective.html">mdMenuDirective</a></li><li><a href="material.components.menu.module_mdSelectDirective.html">mdSelectDirective</a></li><li><a href="material.components.menuBar.module_mdMenuItemDirectiveDecorator.html">mdMenuItemDirectiveDecorator</a></li><li><a href="material.components.select.module_mdSelectMenuDirective.html">mdSelectMenuDirective</a></li><li><a href="material.components.tooltip.module_mdTooltipDirective.html">mdTooltipDirective</a></li></ul><h3>Classes</h3><ul><li><a href="app.core.module_ConfigObject-About.html">About</a></li><li><a href="app.core.module_ConfigObject-Basemap.html">Basemap</a></li><li><a href="app.core.module_ConfigObject-ConfigObject.html">ConfigObject</a></li><li><a href="app.core.module_ConfigObject-Entry.html">Entry</a></li><li><a href="app.core.module_ConfigObject-EPSG.html">EPSG</a></li><li><a href="app.core.module_ConfigObject-ExportComponent.html">ExportComponent</a></li><li><a href="app.core.module_ConfigObject-ExportService.html">ExportService</a></li><li><a href="app.core.module_ConfigObject-ExtentSet.html">ExtentSet</a></li><li><a href="app.core.module_ConfigObject-Help.html">Help</a></li><li><a href="app.core.module_ConfigObject-InfoSection.html">InfoSection</a></li><li><a href="app.core.module_ConfigObject-InitialLayerSettings.html">InitialLayerSettings</a></li><li><a href="app.core.module_ConfigObject-Intentions.html">Intentions</a></li><li><a href="app.core.module_ConfigObject-LayerNode.html">LayerNode</a></li><li><a href="app.core.module_ConfigObject-Legend.html">Legend</a></li><li><a href="app.core.module_ConfigObject-LegendExportComponent.html">LegendExportComponent</a></li><li><a href="app.core.module_ConfigObject-LegendIsOpen.html">LegendIsOpen</a></li><li><a href="app.core.module_ConfigObject-LodSet.html">LodSet</a></li><li><a href="app.core.module_ConfigObject-Map.html">Map</a></li><li><a href="app.core.module_ConfigObject-NavBar.html">NavBar</a></li><li><a href="app.core.module_ConfigObject-Services.html">Services</a></li><li><a href="app.core.module_ConfigObject-SideMenu.html">SideMenu</a></li><li><a href="app.core.module_ConfigObject-StartPoint.html">StartPoint</a></li><li><a href="app.core.module_ConfigObject-TableIsOpen.html">TableIsOpen</a></li><li><a href="app.core.module_ConfigObject-TileSchema.html">TileSchema</a></li><li><a href="app.core.module_ConfigObject-UI.html">UI</a></li><li><a href="app.core.module_ConfigObject-UILegend.html">UILegend</a></li><li><a href="app.core.module_ConfigObject-VisibilitySet.html">VisibilitySet</a></li><li><a href="app.core.module_configService-Config.html">Config</a></li><li><a href="app.geo.module_LayerBlueprintFactory-LayerBlueprint.html">LayerBlueprint</a></li><li><a href="app.geo.module_LayerBlueprintFactory-LayerFileBlueprint.html">LayerFileBlueprint</a></li><li><a href="app.geo.module_LayerBlueprintFactory-LayerServiceBlueprint.html">LayerServiceBlueprint</a></li><li><a href="app.geo.module_LegendBlock-LegendGroup.html">LegendGroup</a></li><li><a href="app.geo.module_LegendBlock-ProxyWrapper.html">ProxyWrapper</a></li><li><a href="app.geo.module_LegendElementFactory-SymbologyControl.html">SymbologyControl</a></li><li><a href="app.ui.module_StepperFactory-Stepper.html">Stepper</a></li><li><a href="app.ui.module_SymbologyStack-SymbologyStack.html">SymbologyStack</a></li><li><a href="app.ui.module_tooltipService-ContainInside.html">ContainInside</a></li><li><a href="app.ui.module_tooltipService-FollowMap.html">FollowMap</a></li><li><a href="app.ui.module_tooltipService-FollowMouse.html">FollowMouse</a></li><li><a href="app.ui.module_tooltipService-Tooltip.html">Tooltip</a></li><li><a href="app.ui.module_tooltipService-TooltipStrategy.html">TooltipStrategy</a></li><li><a href="ConfigObject.UI.html">UI</a></li><li><a href="ExportSize.html">ExportSize</a></li><li><a href="ToggleSymbol.html">ToggleSymbol</a></li><li><a href="Viewer.html">Viewer</a></li><li><a href="ViewerGroup.html">ViewerGroup</a></li></ul><h3>Namespaces</h3><ul><li><a href="app.html">app</a></li><li><a href="app.core.html">core</a></li><li><a href="app.geo.html">geo</a></li><li><a href="app.layout.html">layout</a></li><li><a href="app.ui.html">ui</a></li></ul><h3>Global</h3><ul><li><a href="global.html#$on">$on</a></li><li><a href="global.html#_cfg">_cfg</a></li><li><a href="global.html#addViewer">addViewer</a></li><li><a href="global.html#applyDefault">applyDefault</a></li><li><a href="global.html#attachEvents">attachEvents</a></li><li><a href="global.html#autolink">autolink</a></li><li><a href="global.html#centerAndZoom">centerAndZoom</a></li><li><a href="global.html#configureParser">configureParser</a></li><li><a href="global.html#createCanvas">createCanvas</a></li><li><a href="global.html#createSvg">createSvg</a></li><li><a href="global.html#dateTimeZone">dateTimeZone</a></li><li><a href="global.html#detachEvents">detachEvents</a></li><li><a href="global.html#detectBlur">detectBlur</a></li><li><a href="global.html#detectFocus">detectFocus</a></li><li><a href="global.html#disableCommonPrototypes">disableCommonPrototypes</a></li><li><a href="global.html#elemIsFocusable">elemIsFocusable</a></li><li><a href="global.html#enhanceLogger">enhanceLogger</a></li><li><a href="global.html#fireRvReady">fireRvReady</a></li><li><a href="global.html#focus">focus</a></li><li><a href="global.html#focusableSearch">focusableSearch</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getBookmark">getBookmark</a></li><li><a href="global.html#getCurrentLang">getCurrentLang</a></li><li><a href="global.html#getLogdownInstance">getLogdownInstance</a></li><li><a href="global.html#getRcsLayerIDs">getRcsLayerIDs</a></li><li><a href="global.html#getTextWidth">getTextWidth</a></li><li><a href="global.html#hasLink">hasLink</a></li><li><a href="global.html#initialBookmark">initialBookmark</a></li><li><a href="global.html#isSameActiveElement">isSameActiveElement</a></li><li><a href="global.html#isValid">isValid</a></li><li><a href="global.html#lastVisibleHistoryElement">lastVisibleHistoryElement</a></li><li><a href="global.html#link">link</a></li><li><a href="global.html#loadRcsLayers">loadRcsLayers</a></li><li><a href="global.html#mapCoordinates">mapCoordinates</a></li><li><a href="global.html#mergeCanvases">mergeCanvases</a></li><li><a href="global.html#northArrow">northArrow</a></li><li><a href="global.html#noSourceLink">noSourceLink</a></li><li><a href="global.html#onFocusin">onFocusin</a></li><li><a href="global.html#onFocusout">onFocusout</a></li><li><a href="global.html#onKeydown">onKeydown</a></li><li><a href="global.html#onKeyup">onKeyup</a></li><li><a href="global.html#onMouseDown">onMouseDown</a></li><li><a href="global.html#picture">picture</a></li><li><a href="global.html#preLoadApiBlock">preLoadApiBlock</a></li><li><a href="global.html#process">process</a></li><li><a href="global.html#projectGeometry">projectGeometry</a></li><li><a href="global.html#ready">ready</a></li><li><a href="global.html#readyDelay">readyDelay</a></li><li><a href="global.html#registerPlugin">registerPlugin</a></li><li><a href="global.html#reInitialize">reInitialize</a></li><li><a href="global.html#restoreSession">restoreSession</a></li><li><a href="global.html#RV">RV</a></li><li><a href="global.html#rvDefaults">rvDefaults</a></li><li><a href="global.html#rvFailureImage">rvFailureImage</a></li><li><a href="global.html#rvFocus">rvFocus</a></li><li><a href="global.html#rvNorthArrow">rvNorthArrow</a></li><li><a href="global.html#rvState">rvState</a></li><li><a href="global.html#setLanguage">setLanguage</a></li><li><a href="global.html#setLevel">setLevel</a></li><li><a href="global.html#setMapCursor">setMapCursor</a></li><li><a href="global.html#setSvgHref">setSvgHref</a></li><li><a href="global.html#shiftFocus">shiftFocus</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#svgToCanvas">svgToCanvas</a></li><li><a href="global.html#trackFocusBuilder">trackFocusBuilder</a></li><li><a href="global.html#uid">uid</a></li><li><a href="global.html#updateNorthArrow">updateNorthArrow</a></li><li><a href="global.html#useBookmark">useBookmark</a></li><li><a href="global.html#versionCheck">versionCheck</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri May 11 2018 09:09:27 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
