<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ui/export/export-legend.service.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ui/export/export-legend.service.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import marked from 'marked';
import removeMd from 'remove-markdown';

// margin of the legend container
const LEGEND_MARGIN = {
    t: 20,
    r: 20,
    b: 20,
    l: 20,
};
const SECTION_SPACING = 10; // horizontal spacing between legend sections

const LAYER_GUTTER = 24;
const GROUP_GUTTER = 16;
const INFO_GUTTER = 24;
const ITEM_GUTTER = 8;
const IMAGE_GUTTER = 8;
const SYMBOL_SIZE = 32;

const INFO_FONT_SIZE = 14;

/**
 *
 * @name exportLegendService
 * @module app.ui
 * @requires dependencies
 * @description
 *
 * The `exportLegendService` service generates svg image of the legend breaking into into columns.
 *
 */
angular.module('app.ui').service('exportLegendService', exportLegendService);

function exportLegendService($q, $rootElement, appInfo, LegendBlock, configService, gapiService, graphicsService) {
    const service = {
        generate,
    };

    const ref = {
        showToast: angular.noop,
        hasOmittedImage: false,
    };

    return service;

    /***/

    /**
     * Creates a legend svg graphic from the geoService legend entries.
     * @function generate
     * @param {Number} availableHeight map height, used in legend wraping logic
     * @param {Number} availableWidth width of the legend graphic, should match width of the exported map image
     * @param {Number} preferredSectionWidth width of the individual legend sections inside the legend graphic
     * @param {Number} numColumns optional parameter of the number of columns the legend should be displayed on. 0 or undefined means default generation process
     * @param {Object} legendBlocks optional parameter of legendBlocks to include in graphic. null means default legend generation used
     * @param {Function} showToast a function display a toast notifcation for the user
     * @return {Promise} promise with resolves with a canvas containing the legend
     */
    async function generate(
        availableHeight = 500,
        availableWidth = 1500,
        preferredSectionWidth = 500,
        numColumns = 0,
        legendBlocks = null,
        showToast
    ) {
        // I think this todo is done.
        // TODO: break item names when they overflow even if there are no spaces in the name

        ref.showToast = showToast;

        const legendData = await extractLegendTree(
            legendBlocks || configService.getSync.map.legendBlocks,
            preferredSectionWidth,
            availableWidth
        );

        // resolve with an empty 0 x 0 canvas if there is no layers in the legend
        if (legendData.length === 0) {
            return $q.resolve(graphicsService.createCanvas(0, 0));
        }

        // make a hidden node to construct a legend in
        const hiddenNode = angular.element('&lt;div>').css('visibility', 'hidden');
        $rootElement.append(hiddenNode);

        const legend = SVG(hiddenNode[0]).size(availableWidth, 100);
        const legendSection = legend.group();

        const sectionInfo = {
            count: numColumns || Math.floor(availableWidth / preferredSectionWidth) || 1, // section count should never be 0
            width: 0,
            height: 0,
        };

        let svgLegend; // object containing arrays of svg elements
        let legendDataCopy; // clone the legendData object since it will be modified in place
        let sectionsUsed = null;

        // keep optimizing while the number of used sections differs from the number of available sections
        while (sectionsUsed !== sectionInfo.count) {
            sectionInfo.count = sectionsUsed || sectionInfo.count;
            sectionInfo.width = getSectionWidth();
            legendDataCopy = angular.copy(
                await extractLegendTree(
                    legendBlocks || configService.getSync.map.legendBlocks,
                    sectionInfo.width,
                    availableWidth
                )
            );

            legendSection.clear();

            // create svg legend
            svgLegend = makeLegend(legendSection, legendDataCopy, sectionInfo.width);

            // optimize; get back the number of sections used
            // if only one column available, ignore optimization
            sectionsUsed =
                sectionInfo.count === 1
                    ? 1
                    : gapiService.gapi.legend.makeLegend(legendDataCopy, sectionInfo.count, availableHeight)
                          .sectionsUsed;
        }

        wraplegend(svgLegend, sectionInfo);

        const totalLegendHeight = sectionInfo.height + LEGEND_MARGIN.t + LEGEND_MARGIN.b;

        // set the height of the legend based on the height of its sections
        legend.height(totalLegendHeight).viewbox(0, 0, availableWidth, totalLegendHeight);

        hiddenNode.remove();

        const localCanvas = document.createElement('canvas'); // create canvas element
        const generationPromise = new Promise((resolve) => {
            canvg(localCanvas, legend.node.outerHTML, {
                ignoreAnimation: true,
                ignoreMouse: true,
                renderCallback: () => resolve(localCanvas),
            });
        });

        return generationPromise;

        /**
         * Helper function which calculates the section width based on the number of sections and margins.
         * @function getSectionWidth
         * @private
         * @return {Number} returns the section width
         */
        function getSectionWidth() {
            return (
                (availableWidth - (LEGEND_MARGIN.l + LEGEND_MARGIN.r + (sectionInfo.count - 1) * SECTION_SPACING)) /
                sectionInfo.count
            );
        }
    }

    /**
     * Wraps the single column legend into several by splitting group and redrawing grouping lines
     * @function wraplegend
     * @private
     * @param {Object} svgLegend generated svg legend in a single columns
     * @param {Object} sectionInfo object with the following section parameters:
     *                 {Number} sectionHeight section height
     *                 {Number} sectionWidth section widht
     *                 {Number} sectionCount number of sections to break the legend into
     */
    function wraplegend(svgLegend, sectionInfo) {
        // create wrap legend sections
        const sections = Array.from(Array(sectionInfo.count)).map(() => svgLegend.container.set());

        let sectionId = 0;
        let currentSection = sections[sectionId];

        const itemStoreSet = svgLegend.container.set(); // create a new set for legend items; set is needed to shift all the items at the same time
        const lineStoreSet = svgLegend.lines; // use a group line set from svgLegend

        // moves legend items from an array to a set
        svgLegend.items.forEach((svg) => itemStoreSet.add(svg));

        svgLegend.items.forEach((svg) => {
            // wrap the legend at elements previously marked
            // NOTE: svg.remember('self') retrieves the item that spawned the svg
            // it is a direct reference so the 'splitBefore' added by geoApi can be seen
            if (
                svg.remember('self').splitBefore ||
                (svg.remember('self').parent &amp;&amp; svg.remember('self').parent.splitBefore)
            ) {
                const svgY = svg.y();

                // cut the group lines at the wrapping point
                let i = lineStoreSet.length();
                while (i--) {
                    const line = lineStoreSet.get(i);
                    const [lineX, lineY, lineHeight] = [line.x(), line.y(), line.height()];

                    // if the line starts below the wrapping element, skip
                    if (lineY > svgY) {
                        continue;
                    }

                    // if the line starts above and ends below the wrapping element
                    if (lineY + lineHeight > svgY) {
                        // split the line in two parts: above and below the wrap
                        const up = svgLegend.container
                            .line(lineX, lineY, lineX, Math.min(svgY, sectionInfo.height))
                            .stroke('black');
                        const down = svgLegend.container.line(lineX, svgY, lineX, lineY + lineHeight).stroke('black');

                        line.remove(); // remove original line
                        currentSection.add(up); // store the above part in the  current section
                        lineStoreSet.add(down); // add the below part to the list store for future wrapping (a single line can wrap and be cut multiple time)
                    } else {
                        currentSection.add(line); // if the line fits in the current section, add it there
                    }

                    lineStoreSet.remove(line); // remove that line from the store so it's not processed at further wrappings
                }

                currentSection = sections[++sectionId];

                // shifts legend items and grouped lines up to wrap up current section
                itemStoreSet.dy(-svgY);
                lineStoreSet.dy(-svgY);
            }

            // move a legend item from the bucket store to the current section set
            currentSection.add(svg);
            itemStoreSet.remove(svg);
        });

        // move the left over group lines to the current section
        const lineCount = lineStoreSet.length();
        for (let i = 0; i &lt; lineCount; i++) {
            currentSection.add(lineStoreSet.get(i));
        }

        lineStoreSet.clear();

        // move the sections into proper positions
        sections.forEach((section, index) => {
            const dx = LEGEND_MARGIN.l + sectionInfo.width * index + SECTION_SPACING * index;

            sectionInfo.height = Math.max(sectionInfo.height, section.bbox().h);
            section.dmove(dx, LEGEND_MARGIN.t);

            // draws borders around individual sections
            /*section.rect(sectionInfo.width, sectionInfo.height)
                .dmove(dx, LEGEND_MARGIN.t)
                .fill('transparent').stroke({ color: 'black', opacity: 0.2 }).back();*/
        });
    }

    /**
     * Creates a single column legend from a legend tree object.
     * @function makeLegend
     * @private
     * @param {Object} container parent svg object
     * @param {Array} items top level item in the legend tree object
     * @param {Number} sectionWidth section width to wrap the item name to
     * @return {Object} object with generated legend items and grouping lines, the total legend height and container reference
     */
    function makeLegend(container, items, sectionWidth) {
        let runningHeight = 0;
        let runningIndent = 0;
        const indentD = 16;

        const itemStore = [];
        const lineSet = container.set();

        items.forEach((item) => makeLegendElement(item));

        return {
            container,
            height: runningHeight,
            items: itemStore,
            lines: lineSet,
        };

        /**
         * Makes a legend element (header, group, layer, or a symbology item).
         * @function makeLegendElement
         * @private
         * @param {Object} item legend tree item to use
         */
        function makeLegendElement(item) {
            if (item.blockType &amp;&amp; item.blockType === LegendBlock.TYPES.INFO) {
                // IE uses item.name to store its info sections, make a header and add the gutter
                if (item.name !== '') {
                    makeHeader(item, INFO_FONT_SIZE);
                    runningHeight += INFO_GUTTER;
                } else {
                    // If theres no svgItem created for the info section store it in the first
                    // child so we can tell if we're supposed to break there
                    item.items[0].parent = item;
                }
                // Need to keep a height on the item for geoApi calculations
                item.height = 0;
                item.items.forEach((i) => {
                    makeInfoItem(i);
                    item.height += i.height;
                });
            } else if (item.hasOwnProperty('items')) {
                makeLayer(item);
            } else {
                makeSymbolItem(item);
            }
        }

        /**
         * Creates a layer legend and adds it to the graphic.
         * @function makeLayer
         * @param {Object} layer layer symbology from the legend tree
         */
        function makeLayer(layer) {
            const startHeight = runningHeight;

            makeHeader(layer, 18);

            layer.items.forEach((item) => {
                if (item.hasOwnProperty('items')) {
                    makeGroup(item);
                } else {
                    makeSymbolItem(item);
                }
            });

            // take away the last symbol item's gutter, adds unneeded whitespace
            runningHeight -= ITEM_GUTTER;

            layer.height = runningHeight - startHeight;

            runningHeight += LAYER_GUTTER;
        }

        /**
         * Creates a group legend and adds it to the graphic.
         * @function makeGroup
         * @private
         * @param {Object} group group symbology from the legend tree
         */
        function makeGroup(group) {
            makeHeader(group, 16);

            const startHeight = runningHeight;
            runningIndent++;

            group.items.forEach((item) => {
                makeLegendElement(item);
            });

            runningIndent--;

            const endHeight = runningHeight;
            const line = container
                .line(runningIndent * indentD, startHeight, runningIndent * indentD, endHeight)
                .stroke({ color: 'black', width: 1, opacity: 0.8 });
            lineSet.add(line);

            group.height = runningHeight - startHeight;

            runningHeight += GROUP_GUTTER;
        }

        /**
         * Creates a item legend and adds it to the graphic.
         * @function makeItem
         * @private
         * @param {Object} item item symbology from the legend tree
         * @returns {Object} the item being added
         */
        function makeItem(item) {
            const { name, svgcode } = item;
            const legendItem = container.group().remember('self', item);
            let flow;

            const flowAttributes = {
                'font-family': 'Roboto',
                'font-weight': 'normal',
                'font-size': 14,
                anchor: 'start',
            };

            const imageItem = legendItem.group().svg(svgcode).first();
            const imageItemViewbox = imageItem.viewbox();

            /// Use the narrower width as the bound for the image
            if (imageItemViewbox.width > sectionWidth) {
                const imgLookFactor = 0.9; // So it'd have space on left and right for the visual look
                imageItemViewbox.height *= (sectionWidth / imageItemViewbox.width) * imgLookFactor;
                imageItemViewbox.width = sectionWidth * imgLookFactor;
            }

            if (imageItemViewbox.height > SYMBOL_SIZE || imageItemViewbox.width > SYMBOL_SIZE) {
                flow = legendItem
                    .textflow(name, sectionWidth - runningIndent * indentD)
                    .attr(flowAttributes)
                    .dy(-4);

                imageItem.size(imageItemViewbox.width, imageItemViewbox.height).dy(flow.bbox().height + IMAGE_GUTTER);
            } else {
                flow = legendItem
                    .textflow(name, sectionWidth - SYMBOL_SIZE - IMAGE_GUTTER - runningIndent * indentD)
                    .attr(flowAttributes)
                    .dmove(SYMBOL_SIZE + IMAGE_GUTTER, -4); // (x, y)

                // center line if only one
                if (flow.bbox().height &lt; SYMBOL_SIZE) {
                    flow.cy(SYMBOL_SIZE / 2).dy(-4);
                }
            }

            legendItem.move(runningIndent * indentD, runningHeight);
            runningHeight += Math.max(legendItem.rbox().height, imageItemViewbox.height);

            item.height = legendItem.rbox().height;
            item.y = legendItem.y();

            itemStore.push(legendItem);

            return legendItem;
        }

        /**
         * Calls makeItem with item and adds the proper gutter for info sections
         *
         * @function makeInfoItem
         * @private
         * @param {Object} item item symbology from the legend tree
         */
        function makeInfoItem(item) {
            // info sections have a lot of room at the top, take away the gutter space to make them display better
            runningHeight -= INFO_GUTTER;
            makeItem(item);
            runningHeight += INFO_GUTTER;
        }

        /**
         * Calls makeItem with item and adds the proper gutter for symbology
         *
         * @function makeInfoItem
         * @private
         * @param {Object} item item symbology from the legend tree
         */
        function makeSymbolItem(item) {
            makeItem(item);
            runningHeight += ITEM_GUTTER;
        }

        /**
         * Creates a header and adds it to the graphic.
         * @function makeHeader
         * @private
         * @param {Object} item header item from the legend tree
         * @param {Number} size size of the header
         * @returns {Object} the header being added
         */
        function makeHeader(item, size) {
            const name = item.name || '';
            const header = container
                .textflow(name, sectionWidth - runningIndent * indentD)
                .attr({
                    'font-family': 'Roboto',
                    'font-weight': 'normal',
                    'font-size': size,
                    anchor: 'start',
                })
                .remember('self', item)
                .move(runningIndent * indentD, runningHeight); // TODO: add gutter;

            // store header height and its position for future legend wrapping
            item.headerHeight = header.rbox().height;
            item.y = header.y();
            runningHeight += item.headerHeight + size / 2; // TODO: add gutter

            itemStore.push(header);

            return header;
        }
    }

    /**
     * Extract the flat symbology legend tree from the legend blocks
     *
     * @function extractLegendTree
     * @private
     * @param {LegendBlock} legendBlock the root legend block (or custom plugin legend structure) from which to extract the flat symbology tree.
     * @param {Number} sectionWidth the width of the current section
     * @param {Number} availableWidth the max width of the legend
     * @return {Array} a flat array of layers and their symbology items
     */
    function extractLegendTree(legendBlock, sectionWidth, availableWidth) {
        // `TYPE_TO_SYMBOLOGY` functions return promises
        const TYPE_TO_SYMBOLOGY = {
            [LegendBlock.TYPES.NODE]: (entry) =>
                Promise.resolve({
                    name: entry.name,
                    items: _cleanSymbologyStack(entry.symbologyStack.stack),
                }),
            [LegendBlock.TYPES.GROUP]: async (entry) => ({
                name: entry.name,
                items: await extractLegendTree(entry, sectionWidth, availableWidth),
            }),
            [LegendBlock.TYPES.SET]: () => Promise.resolve(null),
            // eslint-disable-next-line complexity
            [LegendBlock.TYPES.INFO]: async (entry) => {
                if (entry.infoType === 'image') {
                    const svgCode = await _cleanImage(entry.content);
                    return {
                        name: '',
                        items: [{ name: '', svgcode: svgCode }],
                        blockType: LegendBlock.TYPES.INFO,
                        infoType: entry.infoType,
                        height: $(svgCode).height(),
                    };
                } else {
                    const content = entry.layerName || entry.content;

                    // ie can't handle fancy markdown image rendering so we strip markdown entirely
                    if (appInfo.isIE11) {
                        return {
                            name: removeMd(content),
                            items: _cleanSymbologyStack(entry.symbologyStack.stack) || [],
                            blockType: LegendBlock.TYPES.INFO,
                            infoType: entry.infoType,
                        };
                    }

                    const contentToHtml = marked(content);

                    // if no markdown was parsed, return as text
                    if (content === contentToHtml) {
                        return Promise.resolve({
                            name: entry.layerName || entry.content,
                            items: entry.symbologyStack.stack || [],
                            blockType: LegendBlock.TYPES.INFO,
                            infoType: entry.infoType,
                        });
                    }

                    // restrict width to full legend size
                    const correctedWidth = Math.min(sectionWidth, availableWidth - LEGEND_MARGIN.l - LEGEND_MARGIN.r);

                    const container = document.createElement('div');
                    container.innerHTML = contentToHtml;
                    // restrict width and make invisible
                    container.style.width = `${correctedWidth}px`;
                    container.style.display = 'none';
                    // put in dom to be able to get height
                    document.body.appendChild(container);
                    const height = $(container).height();
                    // This is ECCC, we don't litter here.
                    container.remove();

                    // draw an image to the canvas using this XML SVG wrapper
                    const data = `
                        &lt;svg xmlns="http://www.w3.org/2000/svg" width="${correctedWidth}" height="${height}">
                            &lt;foreignObject width="100%" height="100%">
                                &lt;div xmlns="http://www.w3.org/1999/xhtml" style="font-family: Roboto, 'Helvetica Neue', sans-serif;font-size: ${INFO_FONT_SIZE}px;font-weight: 400;letter-spacing: 0.010em;line-height: 20px;">${contentToHtml}&lt;/div>
                            &lt;/foreignObject>
                        &lt;/svg>
                    `;

                    const img = new Image();

                    // https://bugs.chromium.org/p/chromium/issues/detail?id=294129#c26
                    img.src = 'data:image/svg+xml; charset=utf8, ' + encodeURIComponent(data);

                    // we now have a local image and URL that we can wrap in a legend generator supported svg element
                    return Promise.resolve({
                        name: '',
                        items: [
                            {
                                name: '',
                                svgcode: `&lt;svg xmlns:xlink="http://www.w3.org/1999/xlink" height="${height}" width="${correctedWidth}">&lt;image height="${height}" width="${correctedWidth}" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="${img.src}">&lt;/image>&lt;/svg>`,
                            },
                        ].concat(_cleanSymbologyStack(entry.symbologyStack.stack) || []),
                        blockType: LegendBlock.TYPES.INFO,
                        infoType: entry.infoType,
                    });
                }
            },
        };

        // TODO: decide if symbology from the duplicated layer should be included in the export image
        // Not using legendBlock.walk since it ignores any modifications made by export plugins.
        let legendTreeData = iterateLegendBlock(legendBlock);

        /**
         * Traverses the legendBlock object and builds a list of items to include in the legend export.
         *
         * @function iterateLegendBlock
         * @param {*} legendBlock
         * @return {Array} A list of legendBlock entries and null values
         */
        function iterateLegendBlock(legendBlock) {
            let returnVal = [];
            legendBlock.entries.forEach((entry) => {
                returnVal.push(_showBlock(entry) ? TYPE_TO_SYMBOLOGY[entry.blockType](entry) : null);
                if (entry.blockType !== LegendBlock.TYPES.GROUP &amp;&amp; entry.entries) {
                    returnVal = returnVal.concat(iterateLegendBlock(entry));
                }
            });
            return returnVal;
        }

        let titleBefore = false;

        return Promise.all(legendTreeData).then((data) =>
            data
                // filter out nulls
                .filter((a) => a !== null)
                // filter out non-info blocks with no symbology
                .filter((entry) => entry.blockType === LegendBlock.TYPES.INFO || entry.items.length > 0)
                // clear out titles where everything below it (or in between another title) has been removed
                // The two reverses let us filter backwards, making detection of bad titles easier.
                .reverse()
                .filter((entry, index) => {
                    if (entry.infoType &amp;&amp; entry.infoType === 'title') {
                        if (index === 0 || titleBefore) {
                            titleBefore = true;
                            return false;
                        }
                        titleBefore = true;
                    } else {
                        titleBefore = false;
                    }
                    return true;
                })
                .reverse()
        );
    }

    /**
     * Identifies if legend block should be shown in export legend
     *
     * @function _showBlock
     * @private
     * @param {LegendBlock} entry the legend block to be checked whether it should be shown
     * @return {Boolean} true if block should be shown in export legend
     */
    function _showBlock(entry) {
        const exportLegend = configService.getSync.services.export.legend;

        if (entry.controlled &amp;&amp; entry.blockType !== LegendBlock.TYPES.INFO) {
            return exportLegend.showControlledSymbology &amp;&amp; entry.isVisibleOnExport;
        }

        return entry.isVisibleOnExport;
    }

    /**
     * Takes in a symbology stack and replaces any of the non-CORS graphics with a placeholder of
     * the same size if the `cleanCanvas` is set to true in the config file.
     *
     * @param {Array} stack symbology stack from a legend entry/block
     * @returns {Array} a cleaned symbology stack with tainted images removed
     */
    function _cleanSymbologyStack(stack) {
        // if not defined, return empty array
        if (stack === undefined) {
            return [];
        }

        const {
            services: {
                export: { cleanCanvas },
            },
        } = configService.getSync;

        // if `cleanCanvas` is not set, do nothing
        if (!cleanCanvas) {
            return stack;
        }

        const cleaneddStack = stack.map((symbologyItem) => {
            const { name, image, svgcode } = symbologyItem;

            // it's already base 64, hence won't taint the canvas
            // or if the image url is not present into the symbology item's svg code,
            // it means it was successfully converted to base64 (geoApi will always try to load imagery as `anonymous`)
            if (image === undefined || image.startsWith('data:') || svgcode.indexOf(image) === -1) {
                return symbologyItem;
            } else {
                const draw = graphicsService.createSvg(100, 100).svg(svgcode);
                // get the image from the svg and its bounding box
                const bbox = draw.select('image').get(0).bbox();

                // create a placeholder box of the same size and fill it with grey
                // TODO: add a note in it that it can't be exported
                const placeholder = graphicsService.createSvg(bbox.w, bbox.h);
                placeholder.rect(bbox.w, bbox.h).fill('#bdc3c7');

                _notifyLegendCleaned();

                return {
                    name,
                    image,
                    svgcode: placeholder.svg(),
                };
            }
        });

        return cleaneddStack;
    }

    /**
     * Takes in an image url or its dataurl and returns an svg fragment with that image.
     * The tainted, non-CORS image will be replaced with a placehoder of the same size if
     * the `cleanCanvas` option is set to `true` in the config file.
     *
     * @param {*} imgUrl an image url or its dataurl
     * @returns {String} an svg fragment with the supplied image as its url or dataurl
     */
    async function _cleanImage(imgUrl) {
        const imgSource = $rootElement.find(`[src="${imgUrl}"]`)[0];
        const svgResult = graphicsService.createSvg(imgSource.width, imgSource.height); // create svg container

        const {
            services: {
                export: { cleanCanvas },
            },
        } = configService.getSync;

        let dataUrl = imgUrl;

        // if `cleanCanvas` is not set, don't remove non-CORS images
        // if set, try to convert image to dataurl; geoApi will try to load the image as CORS
        if (cleanCanvas) {
            dataUrl = await gapiService.gapi.shared.convertImagetoDataURL(imgUrl);
        }

        // `convertImagetoDataURL` returns original url if loading as anonymous fails
        // if the `dataUrl` starts with `data:`, it's in base 64 already
        if (!cleanCanvas || dataUrl.startsWith('data:') || dataUrl !== imgUrl) {
            svgResult.image(dataUrl, imgSource.width, imgSource.height);
        } else {
            _notifyLegendCleaned();
            svgResult.rect(imgSource.width, imgSource.height).fill('#bdc3c7');
        }

        return svgResult.svg();
    }

    /**
     * Displays a notification to the user that some of the legend graphic are excluded from the legend export.
     * This should only be called when `cleanCanvas` is set to `true`.
     * This notificaiton should be called as early as possible in the export generation.
     *
     */
    function _notifyLegendCleaned() {
        if (ref.hasOmittedImage) {
            return;
        }

        ref.hasOmittedImage = true;
        ref.showToast('error.legend.tainted', { action: '', hideDelay: 5000 });
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="app.common.module_displayManager.html">displayManager</a></li><li><a href="app.common.module_stateManager.html">stateManager</a></li><li><a href="app.core.module_common.html">common</a></li><li><a href="app.core.module_ConfigObject.html">ConfigObject</a></li><li><a href="app.core.module_configService.html">configService</a></li><li><a href="app.geo.module_gapiService.html">gapiService</a></li><li><a href="app.geo.module_Geo.html">Geo</a></li><li><a href="app.geo.module_geoService.html">geoService</a></li><li><a href="app.geo.module_identifyService.html">identifyService</a></li><li><a href="app.geo.module_layerRegistry.html">layerRegistry</a></li><li><a href="app.geo.module_LegendBlock.html">LegendBlock</a></li><li><a href="app.geo.module_LegendElementFactory.html">LegendElementFactory</a></li><li><a href="app.geo.module_legendService.html">legendService</a></li><li><a href="app.geo.module_locateService.html">locateService</a></li><li><a href="app.geo.module_mapService.html">mapService</a></li><li><a href="app.geo.module_mapToolService.html">mapToolService</a></li><li><a href="app.geo.module_metadataService.html">metadataService</a></li><li><a href="app.geo.module_rvInitMap.html">rvInitMap</a></li><li><a href="app.geo.module_rvOverviewToggle.html">rvOverviewToggle</a></li><li><a href="app.layout.module_animationService.html">animationService</a></li><li><a href="app.layout.module_layoutService.html">layoutService</a></li><li><a href="app.layout.module_referenceService.html">referenceService</a></li><li><a href="app.layout.module_rvShell.html">rvShell</a></li><li><a href="app.module_core.html">core</a></li><li><a href="app.module_ui.html">ui</a></li><li><a href="app.ui.module_basemapService.html">basemapService</a></li><li><a href="app.ui.module_detailService.html">detailService</a></li><li><a href="app.ui.module_errorService.html">errorService</a></li><li><a href="app.ui.module_expandImageService.html">expandImageService</a></li><li><a href="app.ui.module_ExportComponent.html">ExportComponent</a></li><li><a href="app.ui.module_exportGenerators.html">exportGenerators</a></li><li><a href="app.ui.module_ExportSize.html">ExportSize</a></li><li><a href="app.ui.module_exportSizesService.html">exportSizesService</a></li><li><a href="app.ui.module_fullScreenService.html">fullScreenService</a></li><li><a href="app.ui.module_geosearchFiltersService.html">geosearchFiltersService</a></li><li><a href="app.ui.module_geosearchService.html">geosearchService</a></li><li><a href="app.ui.module_helpService.html">helpService</a></li><li><a href="app.ui.module_highlightFilter.html">highlightFilter</a></li><li><a href="app.ui.module_layerSource.html">layerSource</a></li><li><a href="app.ui.module_mapNavigationService.html">mapNavigationService</a></li><li><a href="app.ui.module_rvAppbar.html">rvAppbar</a></li><li><a href="app.ui.module_rvBasemap.html">rvBasemap</a></li><li><a href="app.ui.module_rvBasemapItem.html">rvBasemapItem</a></li><li><a href="app.ui.module_rvContentPane.html">rvContentPane</a></li><li><a href="app.ui.module_rvDetails.html">rvDetails</a></li><li><a href="app.ui.module_rvDetailsContent.html">rvDetailsContent</a></li><li><a href="app.ui.module_rvDetailsHeader.html">rvDetailsHeader</a></li><li><a href="app.ui.module_rvDetailsRecordEsrifeature.html">rvDetailsRecordEsrifeature</a></li><li><a href="app.ui.module_rvDetailsRecordEsrifeatureItem.html">rvDetailsRecordEsrifeatureItem</a></li><li><a href="app.ui.module_rvDetailsRecordHtml.html">rvDetailsRecordHtml</a></li><li><a href="app.ui.module_rvDetailsRecordText.html">rvDetailsRecordText</a></li><li><a href="app.ui.module_rvDetectScrollbar.html">rvDetectScrollbar</a></li><li><a href="app.ui.module_rvDragula.html">rvDragula</a></li><li><a href="app.ui.module_rvExportCustomSize.html">rvExportCustomSize</a></li><li><a href="app.ui.module_rvGeosearch.html">rvGeosearch</a></li><li><a href="app.ui.module_rvGeosearchBar.html">rvGeosearchBar</a></li><li><a href="app.ui.module_rvGeosearchBottomFilters.html">rvGeosearchBottomFilters</a></li><li><a href="app.ui.module_rvGeosearchTopFilters.html">rvGeosearchTopFilters</a></li><li><a href="app.ui.module_rvHelpOverlay.html">rvHelpOverlay</a></li><li><a href="app.ui.module_rvHelpSearch.html">rvHelpSearch</a></li><li><a href="app.ui.module_rvLayerListSlider.html">rvLayerListSlider</a></li><li><a href="app.ui.module_rvLegendBlock.html">rvLegendBlock</a></li><li><a href="app.ui.module_rvLoaderFile.html">rvLoaderFile</a></li><li><a href="app.ui.module_rvLoaderMenu.html">rvLoaderMenu</a></li><li><a href="app.ui.module_rvMapnav.html">rvMapnav</a></li><li><a href="app.ui.module_rvMapnavButton.html">rvMapnavButton</a></li><li><a href="app.ui.module_rvMenuLink.html">rvMenuLink</a></li><li><a href="app.ui.module_rvMetadataContent.html">rvMetadataContent</a></li><li><a href="app.ui.module_rvMetadataPanel.html">rvMetadataPanel</a></li><li><a href="app.ui.module_rvMorph.html">rvMorph</a></li><li><a href="app.ui.module_rvPlugSlide.html">rvPlugSlide</a></li><li><a href="app.ui.module_rvReverse.html">rvReverse</a></li><li><a href="app.ui.module_rvSettings.html">rvSettings</a></li><li><a href="app.ui.module_rvSettingsContent.html">rvSettingsContent</a></li><li><a href="app.ui.module_rvSidenav.html">rvSidenav</a></li><li><a href="app.ui.module_rvStepperItem.html">rvStepperItem</a></li><li><a href="app.ui.module_rvSymbologyStack.html">rvSymbologyStack</a></li><li><a href="app.ui.module_rvTableDefault.html">rvTableDefault</a></li><li><a href="app.ui.module_rvTableDefaultMenu.html">rvTableDefaultMenu</a></li><li><a href="app.ui.module_rvTablePanel.html">rvTablePanel</a></li><li><a href="app.ui.module_rvToc.html">rvToc</a></li><li><a href="app.ui.module_rvTocEntryControl.html">rvTocEntryControl</a></li><li><a href="app.ui.module_rvTocExpandMenu.html">rvTocExpandMenu</a></li><li><a href="app.ui.module_rvTocVisibilityMenu.html">rvTocVisibilityMenu</a></li><li><a href="app.ui.module_rvToggleSlide.html">rvToggleSlide</a></li><li><a href="app.ui.module_rvTooltip.html">rvTooltip</a></li><li><a href="app.ui.module_rvTruncate.html">rvTruncate</a></li><li><a href="app.ui.module_sideNavigationService.html">sideNavigationService</a></li><li><a href="app.ui.module_StepperFactory.html">StepperFactory</a></li><li><a href="app.ui.module_SymbologyStack.html">SymbologyStack</a></li><li><a href="app.ui.module_tableService.html">tableService</a></li><li><a href="app.ui.module_tocService.html">tocService</a></li><li><a href="app.ui.module_tooltipService.html">tooltipService</a></li><li><a href="material.components.button.module_MdButtonDirectiveDecorator.html">MdButtonDirectiveDecorator</a></li><li><a href="material.components.dialog.module_$mdDialog.html">$mdDialog</a></li><li><a href="material.components.icon.module_mdIconDirectiveDecorator.html">mdIconDirectiveDecorator</a></li><li><a href="material.components.menu.module_mdMenuDirective.html">mdMenuDirective</a></li><li><a href="material.components.menu.module_mdSelectDirective.html">mdSelectDirective</a></li><li><a href="material.components.menuBar.module_mdMenuItemDirectiveDecorator.html">mdMenuItemDirectiveDecorator</a></li><li><a href="material.components.select.module_mdSelectMenuDirective.html">mdSelectMenuDirective</a></li><li><a href="material.components.tooltip.module_mdTooltipDirective.html">mdTooltipDirective</a></li></ul><h3>Namespaces</h3><ul><li><a href="app.html">app</a></li><li><a href="app.core.html">core</a></li><li><a href="app.geo.html">geo</a></li><li><a href="app.layout.html">layout</a></li><li><a href="app.ui.html">ui</a></li></ul><h3>Classes</h3><ul><li><a href="app.core.module_ConfigObject-About.html">About</a></li><li><a href="app.core.module_ConfigObject-Basemap.html">Basemap</a></li><li><a href="app.core.module_ConfigObject-ConfigObject.html">ConfigObject</a></li><li><a href="app.core.module_ConfigObject-Entry.html">Entry</a></li><li><a href="app.core.module_ConfigObject-ExportComponent.html">ExportComponent</a></li><li><a href="app.core.module_ConfigObject-ExportService.html">ExportService</a></li><li><a href="app.core.module_ConfigObject-ExtentSet.html">ExtentSet</a></li><li><a href="app.core.module_ConfigObject-Help.html">Help</a></li><li><a href="app.core.module_ConfigObject-InfoSection.html">InfoSection</a></li><li><a href="app.core.module_ConfigObject-InitialLayerSettings.html">InitialLayerSettings</a></li><li><a href="app.core.module_ConfigObject-LayerNode.html">LayerNode</a></li><li><a href="app.core.module_ConfigObject-Legend.html">Legend</a></li><li><a href="app.core.module_ConfigObject-LegendExportComponent.html">LegendExportComponent</a></li><li><a href="app.core.module_ConfigObject-LegendIsOpen.html">LegendIsOpen</a></li><li><a href="app.core.module_ConfigObject-LodSet.html">LodSet</a></li><li><a href="app.core.module_ConfigObject-Map.html">Map</a></li><li><a href="app.core.module_ConfigObject-NavBar.html">NavBar</a></li><li><a href="app.core.module_ConfigObject-Services.html">Services</a></li><li><a href="app.core.module_ConfigObject-SideMenu.html">SideMenu</a></li><li><a href="app.core.module_ConfigObject-StartPoint.html">StartPoint</a></li><li><a href="app.core.module_ConfigObject-TableIsOpen.html">TableIsOpen</a></li><li><a href="app.core.module_ConfigObject-TileSchema.html">TileSchema</a></li><li><a href="app.core.module_ConfigObject-UI.html">UI</a></li><li><a href="app.core.module_ConfigObject-UILegend.html">UILegend</a></li><li><a href="app.core.module_ConfigObject-VisibilitySet.html">VisibilitySet</a></li><li><a href="app.core.module_configService-Config.html">Config</a></li><li><a href="app.geo.module_LegendBlock-LegendGroup.html">LegendGroup</a></li><li><a href="app.geo.module_LegendBlock-ProxyWrapper.html">ProxyWrapper</a></li><li><a href="app.geo.module_LegendElementFactory-SymbologyControl.html">SymbologyControl</a></li><li><a href="app.ui.module_StepperFactory-Stepper.html">Stepper</a></li><li><a href="app.ui.module_SymbologyStack-SymbologyStack.html">SymbologyStack</a></li><li><a href="app.ui.module_tooltipService-ContainInside.html">ContainInside</a></li><li><a href="app.ui.module_tooltipService-FollowMap.html">FollowMap</a></li><li><a href="app.ui.module_tooltipService-FollowMouse.html">FollowMouse</a></li><li><a href="app.ui.module_tooltipService-Tooltip.html">Tooltip</a></li><li><a href="app.ui.module_tooltipService-TooltipStrategy.html">TooltipStrategy</a></li><li><a href="ConfigObject.UI.html">UI</a></li><li><a href="ExportSize.html">ExportSize</a></li><li><a href="ToggleSymbol.html">ToggleSymbol</a></li><li><a href="Viewer.html">Viewer</a></li><li><a href="ViewerGroup.html">ViewerGroup</a></li></ul><h3>Global</h3><ul><li><a href="global.html#$on">$on</a></li><li><a href="global.html#_cfg">_cfg</a></li><li><a href="global.html#addViewer">addViewer</a></li><li><a href="global.html#applyDefault">applyDefault</a></li><li><a href="global.html#autolink">autolink</a></li><li><a href="global.html#centerAndZoom">centerAndZoom</a></li><li><a href="global.html#changeIconFocus">changeIconFocus</a></li><li><a href="global.html#configureParser">configureParser</a></li><li><a href="global.html#createCanvas">createCanvas</a></li><li><a href="global.html#createSvg">createSvg</a></li><li><a href="global.html#dateTimeZone">dateTimeZone</a></li><li><a href="global.html#disableCommonPrototypes">disableCommonPrototypes</a></li><li><a href="global.html#elemIsFocusable">elemIsFocusable</a></li><li><a href="global.html#focus">focus</a></li><li><a href="global.html#focusableSearch">focusableSearch</a></li><li><a href="global.html#getBookmark">getBookmark</a></li><li><a href="global.html#getConfig">getConfig</a></li><li><a href="global.html#getCurrentLang">getCurrentLang</a></li><li><a href="global.html#getTextWidth">getTextWidth</a></li><li><a href="global.html#hasLink">hasLink</a></li><li><a href="global.html#imageLoader">imageLoader</a></li><li><a href="global.html#initialBookmark">initialBookmark</a></li><li><a href="global.html#isTainted">isTainted</a></li><li><a href="global.html#isValid">isValid</a></li><li><a href="global.html#lastVisibleHistoryElement">lastVisibleHistoryElement</a></li><li><a href="global.html#link">link</a></li><li><a href="global.html#mergeCanvases">mergeCanvases</a></li><li><a href="global.html#noSourceLink">noSourceLink</a></li><li><a href="global.html#onFocusin">onFocusin</a></li><li><a href="global.html#onFocusout">onFocusout</a></li><li><a href="global.html#onKeydown">onKeydown</a></li><li><a href="global.html#onKeyup">onKeyup</a></li><li><a href="global.html#onMouseDown">onMouseDown</a></li><li><a href="global.html#picture">picture</a></li><li><a href="global.html#preLoadApiBlock">preLoadApiBlock</a></li><li><a href="global.html#process">process</a></li><li><a href="global.html#projectGeometry">projectGeometry</a></li><li><a href="global.html#readyDelay">readyDelay</a></li><li><a href="global.html#resetIconFocus">resetIconFocus</a></li><li><a href="global.html#restoreSession">restoreSession</a></li><li><a href="global.html#RV">RV</a></li><li><a href="global.html#rvCrosshairs">rvCrosshairs</a></li><li><a href="global.html#rvDefaults">rvDefaults</a></li><li><a href="global.html#rvFailureImage">rvFailureImage</a></li><li><a href="global.html#rvFocus">rvFocus</a></li><li><a href="global.html#rvNorthArrow">rvNorthArrow</a></li><li><a href="global.html#rvState">rvState</a></li><li><a href="global.html#setExtent">setExtent</a></li><li><a href="global.html#setMapCursor">setMapCursor</a></li><li><a href="global.html#setSvgHref">setSvgHref</a></li><li><a href="global.html#shellService">shellService</a></li><li><a href="global.html#shiftFocus">shiftFocus</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#svgToCanvas">svgToCanvas</a></li><li><a href="global.html#uid">uid</a></li><li><a href="global.html#updateNorthArrow">updateNorthArrow</a></li><li><a href="global.html#useBookmark">useBookmark</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Wed Nov 23 2022 21:00:04 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
