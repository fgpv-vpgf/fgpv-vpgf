<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ui/toc/symbology-stack.directive.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ui/toc/symbology-stack.directive.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const templateUrl = require('./templates/symbology-stack.html');

const RV_SYMBOLOGY_ITEM_CLASS = '.rv-symbol';
const RV_SYMBOLOGY_ITEM_NAME_CLASS = '.rv-symbol-label';
const RV_COVER_ICON = '.rv-cover-icon';
const RV_SYMBOLOGY_ITEM_TRIGGER = '.rv-symbol-trigger';
const RV_DESCRIPTION_ITEM = '.rv-description-container';

const RV_DURATION = 0.3;
const RV_SWIFT_IN_OUT_EASE = window.Power1.easeInOut;

/**
 * An instance maintains the state of one toggle symbology checkox. This includes if its checked, and the query to use
 */
class ToggleSymbol {
    constructor(symbol) {
        this.isSelected = true;
        this.symbol = symbol;
    }

    click() {
        this.isSelected = !this.isSelected;
    }

    get icon() {
        return this.isSelected ? 'toggle:check_box' : 'toggle:check_box_outline_blank';
    }

    get query() {
        return this.isSelected ? this.symbol.definitionClause : null;
    }
}

/**
 * @module rvSymbologyStack
 * @memberof app.ui
 * @restrict E
 * @description
 *
 * The `rvSymbologyStack` directive generates a symbology list and toggles its visibility. It also wiggles the stacked symbology icons on mouse over and focus.
 *
 * ```html
 * &lt;rv-layer-item-symbology symbology="layer.symbology" container="container">&lt;/rv-layer-item-symbology>
 * ```
 *
 */
/**
 * @module SymbologyStack
 * @memberof app.ui
 * @description
 *
 * `SymbologyStack` class provides a common wrapper around symbology list. This can be used in the details panel, in the legend, or other places where layer symbology need to be displayed.
 * There are two sources of symbology: service symbology and user defined symbology.
 *
 */
angular.module('app.ui').directive('rvSymbologyStack', rvSymbologyStack).factory('SymbologyStack', symbologyStack);

function rvSymbologyStack($rootScope, $rootElement, $q, Geo, configService, animationService, layerRegistry, $timeout) {
    const directive = {
        require: '^?rvTocEntry', // need access to layerItem to get its element reference
        restrict: 'E',
        templateUrl,
        scope: {
            symbology: '=',
            block: '=',
            description: '=?',
            container: '=?',
        },
        link: link,
        controller: () => {},
        controllerAs: 'self',
        bindToController: true,
    };

    return directive;

    /*********/
    // eslint-disable-next-line max-statements
    function link(scope, element) {
        const self = scope.self;
        // if render style is not specified, symbology stack will not be interactive
        // self.isInteractive = typeof self.symbology.renderStyle !== 'undefined';
        self.isExpanded = false; // holds the state of symbology section
        self.showSymbologyToggle = false;

        self.expandSymbology = expandSymbology;
        self.fanOutSymbology = fanOutSymbology;

        self.showSymbologyBorder = showSymbologyBorder;

        self.symbologyWidth = 32;

        self.stackToggled = false;

        // search for any existing legend group
        let groupExists = false;
        let cur = self.block;
        let numParents = 0;
        // this should find the parent group of the current entry, if any, and stop immediately
        while (cur &amp;&amp; cur.parent &amp;&amp; !groupExists) {
            if (cur.constructor.name === 'LegendGroup') {
                groupExists = true;
            } else {
                cur = cur.parent;
                numParents += 1;
            }
        }

        const canvas = document.createElement('canvas');

        // returns true if all toggle symbology checkboxes are checked, false otherwise
        function allSymbolsVisible() {
            const toggleListKeys = Object.keys(self.toggleList);

            return toggleListKeys.filter((key) => self.toggleList[key].isSelected).length === toggleListKeys.length;
        }

        // returns true if no toggle symbology checkboxes are checked, false otherwise
        function noSymbolsVisible() {
            return Object.keys(self.toggleList).filter((key) => self.toggleList[key].isSelected).length === 0;
        }

        // stores instances of ToggleSymbol as key value pairs (with symbol name as the key)
        self.toggleList = [];

        let layerRecord;

        // opening details panel creates a symbology stack, but we don't do symbology toggling there so ignore error
        try {
            layerRecord = layerRegistry.getLayerRecord(self.block.layerRecordId);
        } catch (e) {
            // do nothing
        }

        // Helper function: apply definition to filter system
        function applySymbolFilter(defClause) {
            // TODO need a test for proxyWrapper?  it might not be ready yet?  might need a watch on 'loaded' if not ready
            const fs = self.block.proxyWrapper.filterState;
            if (fs !== undefined) {
                // tile layers, image layers and wms layers will not have filter state defined
                fs.setSql(fs.coreFilterTypes.SYMBOL, defClause);
            }
        }

        // Helper function: update symbol toggles
        function updateToggles(val) {
            if (val) {
                const someOn = self.toggleList.some((toggle) => toggle.wasSelected === true);
                self.toggleList.forEach((toggle) => {
                    if ((toggle.wasSelected &amp;&amp; toggle.isSelected === false) || !someOn) {
                        toggle.wasSelected = undefined;
                        self.onToggleClick(toggle, true);
                    }
                });
            } else {
                self.toggleList.forEach((toggle) => {
                    if (toggle.isSelected !== false) {
                        toggle.wasSelected = true;
                        self.onToggleClick(toggle, false);
                    } else {
                        toggle.wasSelected = undefined;
                    }
                });
            }
        }

        // wire up a listener on the visibility change of the legend block
        if (self.block &amp;&amp; self.block.visibilityChanged) {
            // change all symbology stack to toggled/untoggled if top layer is visible/invisible
            // TODO update this code when issue 3152 is implemented
            self.block.visibilityChanged.subscribe((val) => {
                // make sure this doesn't fire if an individual symbology being toggled triggered visibilityChanged
                // only toggle when toggling visibility on after all symbology have been turned off
                if (!self.stackToggled) {
                    const query = val ? '' : '1=2';
                    if (self.block.proxyWrapper.isActiveState) {
                        // layer is loaded, apply stuff now
                        // only update if currently selected...otherwise causes all sorts of race conditions
                        // TODO ensure this is race condition no longer exists in new filter structure
                        // TODO once things are working, move these two statements to a function and call in both locations.
                        applySymbolFilter(query);
                        updateToggles(val);
                    } else {
                        // layer not yet loaded, wait until it is then apply stuff
                        const proxyLoaded = $rootScope.$watch(
                            () => self.block.proxyWrapper.state,
                            (state, oldState) => {
                                // TODO if possible, link in to Geo.Layer.States and use the LOADED constant
                                if (state === 'rv-loaded') {
                                    // only update if currently selected...otherwise causes all sorts of race conditions
                                    // TODO ensure this is race condition no longer exists in new filter structure
                                    applySymbolFilter(query);
                                    updateToggles(val);
                                    self.stackToggled = false;
                                    proxyLoaded();
                                }
                            }
                        );
                    }
                }
                self.stackToggled = false;
            });
        }

        // triggerFilter is suppressed when toggles are being synchronized/initialized.  avoids sending off multiple filter updates
        self.onToggleClick = (toggle, triggerFilter = true) => {
            toggle.click();

            let defClause;

            if (allSymbolsVisible()) {
                // when all symbols are checked, clearing the query is the same as trying to match all of them
                defClause = '';
            } else if (noSymbolsVisible()) {
                // when no symbols are checked, make a query that is never true so no symbols are shown
                defClause = '1=2';
            } else {
                //otherwise proceed with joining geoApi definitionClauses
                defClause = self.toggleList
                    .map((toggle) => toggle.query)
                    .filter((q) => q !== null)
                    .join(' OR ');
            }

            if (triggerFilter) {
                applySymbolFilter(defClause);
                self.block._symbolVisibilityChanged.next();

                // Turn off layer if all symbols are unchecked
                let noSymb = noSymbolsVisible();
                if (noSymb) {
                    self.block.visibility = false;
                } else if (!noSymb &amp;&amp; self.block.visibility === false) {
                    self.stackToggled = true;
                    self.block.visibility = true;
                    self.toggleList.forEach((toggle) => {
                        toggle.wasSelected = undefined;
                    });
                }
            }

            // TODO this appears to handle a checkevent prior to layer loading, and will notify API observables that
            //      the symbol visibility changed after the layer loads
            //      confused why this only triggers if definition clause is undefined (now '');
            //      that would indiicate we only trigger symbolVisibilitychanged when all are set to visible.  i think
            //      we should be triggering visibility changes any time it changes.
            //      might also want to wrap this inside the triggerFilter, to avoid calling it when
            //      things are being setup.
            //      need to consult API people on how to best call _symbolVisibilityChanged.next();
            /*
            if (defClause === '') {
                if (self.block.validOIDs === undefined) {
                    const proxyLoaded = $rootScope.$watch(() => self.block.proxyWrapper.state, (state, oldState) => {
                        if (state === 'rv-loaded') {
                            self.block._symbolVisibilityChanged.next();
                            proxyLoaded();
                        }
                    });
                }
            }
            */
        };

        //wire in a hook to the SymbologyStack item!
        if (self.symbology) {
            self.symbology.toggleList = self.toggleList;
            self.symbology.onToggleClick = self.onToggleClick;
            self.symbology.allSymbolsVisible = allSymbolsVisible;
            self.symbology.noSymbolsVisible = noSymbolsVisible;
        }

        const ref = {
            isReady: false,

            isFannedOut: false,

            expandTimeline: null, // expand/collapse animation timeline
            fanOutTimeline: null, // wiggle animation timeline

            descriptionItem: null,

            // store reference to symbology nodes
            // the following are normal arrays of jQuery items, NOT jQuery pseudo-arrays
            symbolItems: [],
            // cover item stays with the stack when the rest of the stack is expanded
            coverSymbolItem: null,
            trigger: null, // expand self.trigger node

            // TODO: container width will depend on app mode: desktop or mobile; need a way to determine this
            containerWidth: 350,
            maxItemWidth: 350,
        };

        scope.$watch(
            () => element.parent().width(),
            (value) => {
                if (value) {
                    ref.containerWidth = value;
                    updateContainerWidth(value);
                }
                scope.$applyAsync();
            }
        );

        scope.$watch('self.showSymbologyToggle', (value) => {
            if (value) {
                element.find('.md-icon-button').addClass('show');
            } else {
                element.find('.md-icon-button').removeClass('show');
            }
        });

        // description persist, so need to store reference only once
        ref.descriptionItem = element.find(RV_DESCRIPTION_ITEM);
        ref.descriptionItem.css('width', ref.containerWidth);

        scope.$watchCollection('self.symbology.stack', (newStack, oldStack) => {
            if (newStack) {
                ref.isReady = false;
                ref.toggleLoaded = false;

                // collapse the stack when underlying collection of the symbology changes as the expanded ui stack might initialy had a different number of items
                if (self.isExpanded) {
                    self.expandSymbology(false);
                }

                // A layer can have `toggleSymbology` set to false in the config, in which case we don't create checkboxes.
                // If a dynamic is a raster layer the symbology toggles do nothing so they should be disabled
                // TODO check if we need to add file-based stuff here
                if (
                    layerRecord &amp;&amp;
                    (layerRecord.layerType === Geo.Layer.Types.ESRI_DYNAMIC ||
                        layerRecord.layerType === Geo.Layer.Types.ESRI_FEATURE) &amp;&amp;
                    layerRecord.config.toggleSymbology &amp;&amp;
                    self.symbology.stack.length > 1 &amp;&amp;
                    self.symbology._proxy.layerType !== Geo.Layer.Types.ESRI_RASTER
                ) {
                    const stackConfig = self.block.blockConfig.symbologyStack;
                    const drawPromises = self.symbology.stack.map((s) => s.drawPromise);

                    $q.all(drawPromises).then(() => {
                        // create a ToggleSymbol instance for each symbol
                        self.symbology.stack.forEach((s) => {
                            // check legend config to see if the user has provided a definition clause
                            // user's definition clause takes priority over automatically generated one
                            const currIndex = self.symbology.stack.indexOf(s);
                            s.definitionClause =
                                stackConfig !== null &amp;&amp; stackConfig[currIndex].sqlQuery !== undefined
                                    ? stackConfig[currIndex].sqlQuery
                                    : s.definitionClause;

                            if (s.definitionClause) {
                                // If the symbol doesn't have a query it shouldn't be a toggle symbol
                                const toggle = new ToggleSymbol(s);
                                s.toggle = toggle;
                                self.toggleList.push(toggle);

                                // toggle list gets generated each time block is reloaded, make sure check boxes and definition queries actually match the toggle list
                                self.toggleList.forEach((toggle) => {
                                    if (toggle.isSelected !== self.block.visibility) {
                                        self.onToggleClick(toggle, false);
                                    }
                                });
                            }
                        });

                        self.toggleLoaded = true;
                    });
                }
            }

            // if there exists a legend group, watch for when the group gets expanded
            if (groupExists) {
                // for obtaining the link to the parent group block
                let parent = '.parent'.repeat(numParents);
                scope.$watch('self.block' + parent + '.expanded', (newValue, oldValue) => {
                    // when parent group is expanded, expand symbology stack if needed
                    if (newValue !== oldValue &amp;&amp; newValue) {
                        // calling expandSymbology twice fixes some corner cases
                        $timeout(() => self.expandSymbology(self.symbology.expanded), 0);
                    }
                });
            }

            scope.$watch('self.symbology.expanded', (newValue, oldValue) =>
                newValue !== oldValue ? self.expandSymbology(newValue) : angular.noop
            );

            scope.$watch('self.symbology.fannedOut', (newValue, oldValue) =>
                newValue !== oldValue ? self.fanOutSymbology(newValue) : angular.noop
            );

            // Wait here and then expand the symbology stack if needed. Waits
            // to ensure that the checkboxes are fully loaded (or not required) before opening the symbology.
            if (!groupExists || cur.expanded) {
                $timeout(() => {
                    if (self.toggleList.length == 0 || (self.toggleList.length > 0 &amp;&amp; self.toggleLoaded)) {
                        self.expandSymbology(self.symbology.expanded);
                    }
                }, 1000);
            }
        });

        return true;

        /**
         * Draws a black box around the symbology stack for accessibility purposes.
         *
         * @function showSymbologyBorder
         * @private
         * @param {Boolean} toggle true will draw an outline around the stack; false will remove the border
         */
        function showSymbologyBorder(toggle) {
            // If the viewer isn't in keyboard mode don't bother drawing these outlines.
            if (!$rootElement.hasClass('rv-keyboard')) {
                return;
            }

            // If a value is provided (aka the symbology was focused or blurred), then apply the outline as necessary.
            if (toggle !== undefined) {
                toggle &amp;&amp; !self.isExpanded
                    ? element.addClass('rv-symbol-outline')
                    : element.removeClass('rv-symbol-outline');
            } else {
                // If no value is provided (aka the symbology was clicked), then ensure that the border is removed if the
                // symbology is expanded (to prevent a double border around the symbology and the close button).
                self.isExpanded ? element.addClass('rv-symbol-outline') : element.removeClass('rv-symbol-outline');
            }
        }

        /**
         * Expands the symbology stack to show all its individual elements.
         *
         * @function expandSymbology
         * @private
         * @param {Boolean} value [optional = !self.isExpanded] true will expand the stack; false, collapse the stack;
         */
        function expandSymbology(value = !self.isExpanded) {
            // if symbology is non-interactive, don't do anything
            if (!self.symbology.isInteractive) {
                return;
            }

            //call to initializeTimelines() could make ref.isReady === true
            if (!ref.isReady) {
                initializeTimelines();
            }

            //only makes sense to expand or collapse symbology items if all references are ready
            if (ref.isReady) {
                if (value) {
                    // expand symbology items and reverse wiggle
                    ref.expandTimeline.play();
                    ref.fanOutTimeline.reverse();
                } else {
                    // collapse symbology items and forward play wiggle
                    ref.expandTimeline.reverse();
                    self.showSymbologyToggle = false;
                    ref.fanOutTimeline.play();
                }
                const expandedChanged = self.symbology.expanded !== value;
                self.symbology.expanded = value;

                // alert user that symbology has been expanded/collapsed
                if (expandedChanged) {
                    const map = configService.getSync.map.instance;
                    const alertMsg = self.symbology.expanded
                        ? 'toc.layer.label.symbologyExpand'
                        : 'toc.layer.label.symbologyCollapse';
                    map.updateAlert(alertMsg);
                }
            }
        }

        /**
         * Fans out the symbology stack; is used to indicate interactive nature of the symbology stack.
         *
         * @function fanOutSymbology
         * @private
         * @param {Boolean} value [optional = !ref.isFannedOut] true will fanOut the stack; false, close the fan;
         */
        function fanOutSymbology(value = !ref.isFannedOut) {
            // if symbology is non-interative, don't do anything
            if (!self.symbology.isInteractive) {
                return;
            }

            //call to initializeTimelines() could make ref.isReady === true
            if (!ref.isReady) {
                initializeTimelines();
            }

            if (ref.isReady) {
                // on mouse over, wiggle only if symbology is not expanded or animating
                if (value &amp;&amp; !self.isExpanded &amp;&amp; !ref.expandTimeline.isActive()) {
                    ref.fanOutTimeline.play();
                } else {
                    // on mouse out, set wiggle timeline to 0 if symbology is expanded or animating
                    if (ref.expandTimeline.isActive() || self.isExpanded) {
                        ref.fanOutTimeline.pause(0);
                    } else if (!self.isExpanded &amp;&amp; !ref.expandTimeline.isActive()) {
                        // ... reverse wiggle, if symbology is collapsed and not animating
                        ref.fanOutTimeline.reverse();
                    }
                }

                self.symbology.fannedOut = value;
            }
        }

        // find and store references to relevant nodes
        function initializeTimelines() {
            if (!self.symbology.isInteractive) {
                return;
            }

            // find all symbology items and their parts including the cover symbol if it exists
            [ref.symbolItems, ref.coverSymbolItem] = element
                .find(RV_SYMBOLOGY_ITEM_CLASS)
                .toArray()
                .reduce(
                    ([symbols, coverSymbol], domNode) => {
                        domNode = angular.element(domNode);

                        const symbol = {
                            container: domNode,
                            image: domNode.find('rv-svg'),
                            label: domNode.find(RV_SYMBOLOGY_ITEM_NAME_CLASS),
                        };

                        // sort regular symbols from the cover symbol
                        return domNode.hasClass(RV_COVER_ICON.slice(1))
                            ? [symbols, symbol]
                            : [[...symbols, symbol], coverSymbol];
                    },
                    [[], null]
                );

            ref.trigger = element.find(RV_SYMBOLOGY_ITEM_TRIGGER);

            // calculate maximum width of a symbology item based on image, label size and the main panel width
            // symbology item cannot be wider than the panel
            ref.maxItemWidth = Math.min(
                Math.max(
                    ...ref.symbolItems.map((symbolItem) => {
                        const svgImage = symbolItem.image.find('svg')[0];
                        const texLRPadding =
                            parseInt(symbolItem.label.css('padding-left').slice(0, -2)) +
                            parseInt(symbolItem.label.css('padding-right').slice(0, -2));
                        return Math.max(
                            svgImage ? svgImage.viewBox.baseVal.width : 0,
                            getTextWidth(canvas, symbolItem.label.text(), 'normal 14px Roboto') + texLRPadding
                        );
                    })
                ),
                ref.containerWidth - 28 // subtract symbol stack left offset
            );

            //permit ref to be ready only when all symbology images are properly loaded
            let isReady = ref.symbolItems.every((symbolItem) => symbolItem.image.find('svg')[0] !== undefined);

            //only allow math for expanding/fanning out the stack when all images properly loaded
            //else causes negative margins and disappearing legend entries
            if (isReady) {
                ref.expandTimeline = makeExpandTimeline();
                ref.fanOutTimeline = makeWiggleTimeline();
                ref.isReady = ref.maxItemWidth > 0;
            }
        }

        function makeExpandTimeline() {
            const timeline = animationService.timeLineLite({
                paused: true,
                onStart: () => {
                    self.isExpanded = true;
                    scope.$digest();
                },
                onComplete: () => {
                    self.showSymbologyToggle = true;
                    updateContainerWidth(ref.containerWidth);
                    scope.$digest();
                },
                onReverseComplete: () => {
                    self.isExpanded = false;
                    self.symbologyWidth = 32;
                    scope.$digest();
                },
            });

            // in pixels
            const symbologyListTopOffset = 48; // offset to cover the height of the legend entry node
            const symbologyListMargin = 16; // gap between the legend endtry and the symbology stack

            // keep track of the total height of symbology stack so far
            let totalHeight = symbologyListTopOffset + symbologyListMargin;

            // optional description is displayed above the symbology items
            if (self.description !== '') {
                totalHeight -= symbologyListMargin / 2;

                // briefly show the description node to grab it's height, and hide it again
                ref.descriptionItem.show();
                let width = getTextWidth(canvas, ref.descriptionItem.text(), ref.descriptionItem.css('font'));
                let height =
                    Math.ceil(width / ref.descriptionItem.width()) *
                    parseInt(ref.descriptionItem.css('line-height').slice(0, -2));
                const descriptionHeight = ref.descriptionItem.height() > 0 ? ref.descriptionItem.height() : height;
                ref.descriptionItem.hide();

                // move the node into position unhiding it (it's still invisible beacuse opacity is 0)
                timeline.set(ref.descriptionItem, {
                    display: 'block',
                    top: totalHeight - 30,
                });

                // show and animate description node
                timeline.to(
                    ref.descriptionItem,
                    (RV_DURATION / 3) * 2,
                    {
                        opacity: 1,
                        top: totalHeight,
                        ease: RV_SWIFT_IN_OUT_EASE,
                    },
                    RV_DURATION / 3
                );

                // include the description height in the total height of the symbology stack
                totalHeight += descriptionHeight + symbologyListMargin;
            }

            // future-proofing - in case we need different behaviours for other legend types
            const legendItemTLgenerator = {
                images: imageLegendItem,
                icons: iconLegendItem,
            };

            // loop over ref.symbolItems, generate timeline for each one, increase total height
            ref.symbolItems.forEach((symbolItem, index) => {
                const heightIncrease = legendItemTLgenerator[self.symbology.renderStyle](
                    timeline,
                    symbolItem,
                    totalHeight,
                    index === ref.symbolItems.length - 1
                );

                totalHeight += heightIncrease;
            });

            totalHeight += symbologyListMargin; // add margin at the bottom of the list

            // expand layer item container to accomodate symbology list
            // if no container specified, skip this part of animation; as a result, the expanded symbology stack may overflow its parent node
            if (self.container) {
                timeline.to(
                    self.container,
                    RV_DURATION,
                    {
                        marginBottom: totalHeight - symbologyListTopOffset,
                        ease: RV_SWIFT_IN_OUT_EASE,
                    },
                    0
                );
            }

            // show the self.trigger button
            timeline.to(
                ref.trigger,
                RV_DURATION - 0.1,
                {
                    opacity: 1,
                    ease: RV_SWIFT_IN_OUT_EASE,
                },
                0.1
            );

            return timeline;
        }

        function makeWiggleTimeline() {
            // we only need one timeline since we can reuse it
            const timeline = animationService.timeLineLite({
                paused: true,
                onStart: () => {
                    ref.isFannedOut = true;
                },
                onReverseComplete: () => {
                    ref.isFannedOut = false;
                },
            });

            // do not
            if (ref.coverSymbolItem) {
                timeline.to(
                    ref.coverSymbolItem.container,
                    RV_DURATION,
                    {
                        transform: 'scale(1.2, 1.2)',
                        ease: RV_SWIFT_IN_OUT_EASE,
                    },
                    0
                );

                return timeline;
            } else {
                const displacement = 4;

                // if there is just one icon, don't do on-hover animation
                if (ref.symbolItems.length > 1) {
                    // wiggle the first icon in the stack
                    timeline.to(
                        ref.symbolItems[0].container,
                        RV_DURATION,
                        {
                            x: `-=${displacement}px`,
                            y: `-=${displacement}px`,
                            ease: RV_SWIFT_IN_OUT_EASE,
                        },
                        0
                    );

                    // wiggle the last icon in the stack
                    timeline.to(
                        ref.symbolItems.slice(-1).pop().container,
                        RV_DURATION,
                        {
                            x: `+=${displacement}px`,
                            y: `+=${displacement}px`,
                            ease: RV_SWIFT_IN_OUT_EASE,
                        },
                        0
                    );
                }

                return timeline;
            }
        }

        /**
         * Creates timeline for a supplied image-based symbolItem (for wms legends for example)
         * @function imageLegendItem
         * @param  {Object}  timeline       timeline object
         * @param  {Object}  symbolItem symbology object with references to its parts
         * @param  {Number}  totalHeight   height of the legend stack so far
         * @param  {Boolean} isLast        flag indicating this is the last item in the stack
         * @return {Number}                height of this symbology item plus its bottom margin is applicable
         */
        function imageLegendItem(timeline, symbolItem, totalHeight, isLast) {
            const symbologyListItemMargin = 16;
            const imageWidth = symbolItem.image.find('svg')[0].viewBox.baseVal.width;
            const imageHeight = symbolItem.image.find('svg')[0].viewBox.baseVal.height;

            // calculate symbology item's dimensions based on max width
            const itemWidth = Math.min(ref.maxItemWidth, imageWidth);
            const itemHeight = imageWidth !== 0 ? (itemWidth / imageWidth) * imageHeight : 0; // in cases when image urls are broken its size is 0

            // extremely convoluted math to calculate an aproximation of the label's height
            // can't just get outerHeight() since it returns strange values when the symbology stack isn't expanded
            let labelHeight = 0;
            let lineHeight = 0;
            let padding = 0;
            const textWidth = getTextWidth(canvas, symbolItem.label[0].innerText, symbolItem.label.css('font'));
            if (textWidth > 0) {
                lineHeight = parseInt(symbolItem.label.css('line-height').slice(0, -2));
                padding =
                    parseInt(symbolItem.label.css('padding-bottom').slice(0, -2)) +
                    parseInt(symbolItem.label.css('padding-top').slice(0, -2));
                const sidePadding =
                    parseInt(symbolItem.label.css('padding-left').slice(0, -2)) +
                    parseInt(symbolItem.label.css('padding-right').slice(0, -2));
                labelHeight =
                    Math.floor(textWidth / (0.9 * (ref.maxItemWidth - sidePadding)) + 1) * lineHeight + padding; // divide by 0.9 due to display rounding
            }

            // animate symbology container's size
            // note that animate starts at `RV_DURATION / 3 * 2` giving the items time to move down from the stack
            // so they don't overlay legend entry
            timeline.to(
                symbolItem.container,
                (RV_DURATION / 3) * 2,
                {
                    width: ref.maxItemWidth,
                    height: itemHeight + labelHeight,
                    left: 0,
                    autoAlpha: 1,
                    ease: RV_SWIFT_IN_OUT_EASE,
                },
                RV_DURATION / 3
            );

            // move item down
            timeline.to(
                symbolItem.container,
                RV_DURATION,
                {
                    top: totalHeight,
                    ease: RV_SWIFT_IN_OUT_EASE,
                },
                0
            );

            // animate image width to the calculated width
            timeline.to(
                symbolItem.image,
                (RV_DURATION / 3) * 2,
                {
                    width: itemWidth,
                    height: itemHeight,
                    padding: 0, // removes padding from expanded wms legend images making them clearer; TODO: revisit when all symbology is svg items
                    ease: RV_SWIFT_IN_OUT_EASE,
                },
                RV_DURATION / 3
            );

            // set width to auto to keep the label centered during animation
            timeline.set(
                symbolItem.label,
                {
                    display: 'block',
                    width: 'auto',
                },
                0
            );

            // animate symbology label into view
            timeline.to(
                symbolItem.label,
                RV_DURATION / 3,
                {
                    opacity: 1,
                    ease: RV_SWIFT_IN_OUT_EASE,
                },
                (RV_DURATION / 3) * 2
            );

            return itemHeight + labelHeight + (isLast ? 0 : symbologyListItemMargin);
        }

        /**
         * Creates timeline for a supplied icon-based symbolItem (for feature and dynamic legends for example)
         * @function iconLegendItem
         * @param  {Object}  timeline       timeline object
         * @param  {Object}  symbolItem symbology object with references to its parts
         * @param  {Number}  totalHeight   height of the legend stack so far
         * @param  {Boolean} isLast        flag indicating this is the last item in the stack
         * @return {Number}                height of this symbology item plus its bottom margin is applicable
         */
        function iconLegendItem(timeline, symbolItem, totalHeight, isLast) {
            const symbologyListItemMargin = 8;

            const itemSize = 32; // icon size is fixed

            // expand symbology container width and align it to the left (first and last items are fanned out)
            timeline.to(
                symbolItem.container,
                (RV_DURATION / 3) * 2,
                {
                    width: ref.containerWidth,
                    left: 0,
                    ease: RV_SWIFT_IN_OUT_EASE,
                },
                RV_DURATION / 3
            );

            // shift the symbology item down to the bottom of the stack using the total height
            timeline.to(
                symbolItem.container,
                RV_DURATION,
                {
                    top: totalHeight,
                    ease: RV_SWIFT_IN_OUT_EASE,
                },
                0
            );

            // by default, items 3 to n-1 are hidden (their shadows stack otherwise)
            // animate them back into view
            timeline.to(
                symbolItem.container,
                RV_DURATION / 3,
                {
                    autoAlpha: 1,
                    ease: RV_SWIFT_IN_OUT_EASE,
                },
                0
            );

            // animate image width to the calculated width
            timeline.to(
                symbolItem.image,
                (RV_DURATION / 3) * 2,
                {
                    width: itemSize,
                    height: itemSize,
                    ease: RV_SWIFT_IN_OUT_EASE,
                },
                RV_DURATION / 3
            );

            // set label to `block` so it is properly positioned
            timeline.set(
                symbolItem.label,
                {
                    display: 'block',
                },
                RV_DURATION / 3
            );

            // animate symbology label into view
            timeline.to(
                symbolItem.label,
                (RV_DURATION / 3) * 2,
                {
                    opacity: 1,
                    ease: RV_SWIFT_IN_OUT_EASE,
                },
                RV_DURATION / 3
            );

            return itemSize + (isLast ? 0 : symbologyListItemMargin);
        }

        /**
         * Returns width of the supplied text string.
         * @function getTextWidth
         * @param  {Object} canvas cached canvas node
         * @param  {String} text   string of text to measure
         * @param  {String} font   text font and size https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font
         * @return {Number}        width of the text
         */
        function getTextWidth(canvas, text, font) {
            const context = canvas.getContext('2d');
            context.font = font;

            // measure text width on the canvas: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/measureText
            const metrics = context.measureText(text);
            return metrics.width;
        }

        /**
         * Updates container width to allign the symbology checkboxes
         * @function updateContainerWidth
         * @param {number} value
         */
        function updateContainerWidth(value) {
            if (self.isExpanded &amp;&amp; self.toggleList.length > 0 &amp;&amp; ref.expandTimeline &amp;&amp; !ref.expandTimeline.isActive()) {
                self.symbologyWidth = value;
                scope.$applyAsync();
            }
        }
    }
}

function symbologyStack($q, $rootScope, ConfigObject, gapiService) {
    class SymbologyStack {
        /**
         * Creates a new symbology stack. All parameters are options and if none is supplied, an empty stack will be created.
         *
         * @param {LayerProxy|Promise&lt;LayerProxy>} proxy [optional = {}] layer proxy object or a promise returning a proxy object which can supply symbology stack; custom symbols will be used first; if they are not availalbe, symbology stack from the proxy object is used;
         * @param {Array} symbols [optional = null] array of alternative symbology svg graphic elements; can be either [ { name: &lt;String>, svgcode: &lt;String> }, ... ] or [ { text: &lt;String>, image: &lt;String> }, ... ]; the latter example (usually coming from a config file) will be transformed into the format by wrapping images in svg containers;
         * @param {String} coverIcon [optional = String] a graphic to be displayed as a cover icon for the symbology stack but which stays put and does not move
         * @param {String} renderStyle [optional = ConfigObject.legend.Entry.ICONS] rendering style for symbology stack animation
         * @param {String} expanded [optional = false] specifies if symbolbogy stack is expanded
         * @param {Boolean} isInteractive [optional = false] specifies if the user can interact with the symbology stack
         */
        // eslint-disable-next-line complexity
        constructor(
            proxy = null,
            symbols = null,
            coverIcon = null,
            renderStyle = ConfigObject.legend.Entry.ICONS,
            expanded = false,
            isInteractive = false
        ) {
            // resolve proxy promise and store the proxy object itself
            if (proxy) {
                $q.resolve(proxy)
                    .then((proxy) => (this._proxy = proxy))
                    .catch(() => {}); // ignore proxyPromise error; if that happens, symbology will not be shown anyway
            }

            this._renderStyle = renderStyle;

            this._fannedOut = false;
            this._expanded = expanded;

            const renderStyleSwitch = {
                [ConfigObject.legend.Entry.ICONS]: gapiService.gapi.symbology.listToIconSymbology,
                [ConfigObject.legend.Entry.IMAGES]: gapiService.gapi.symbology.listToImageSymbology,
            };

            // is the provided symbols is not an array, set to null
            if (!angular.isArray(symbols)) {
                this._symbols = null;
            } else {
                // custom symbology lists coming from the config file need to be converted to svg first
                this._symbols =
                    symbols.length > 0 &amp;&amp; symbols[0].image ? renderStyleSwitch[renderStyle](symbols) : symbols;
            }

            // if a cover icon is specified, convert it to svg as well
            if (coverIcon) {
                this._coverIcon = renderStyleSwitch[ConfigObject.legend.Entry.ICONS]([
                    {
                        text: '',
                        image: coverIcon,
                    },
                ])[0];
            }

            this._isInteractive = isInteractive;
        }

        _proxy = null;
        _coverIcon = null;

        /**
         * @return {Boolean} true if the symbology stack can be expanded by the user; false if not;
         */
        get isInteractive() {
            // the stack can only be interactive if there is at least one symbol
            return this.stack &amp;&amp; this.stack.length === 0 ? false : this._isInteractive;
        }

        get stack() {
            return this._symbols || (this._proxy ? this._proxy.symbology : []) || [];
        }

        get renderStyle() {
            return this._renderStyle;
        }

        get coverIcon() {
            return this._coverIcon;
        }

        get fannedOut() {
            return this._fannedOut;
        }

        set fannedOut(value) {
            this._fannedOut = value;
        }

        get expanded() {
            return this._expanded;
        }

        set expanded(value) {
            this._expanded = value;
            $rootScope.$applyAsync();
        }
    }

    return SymbologyStack;
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="app.common.module_displayManager.html">displayManager</a></li><li><a href="app.common.module_stateManager.html">stateManager</a></li><li><a href="app.core.module_common.html">common</a></li><li><a href="app.core.module_ConfigObject.html">ConfigObject</a></li><li><a href="app.core.module_configService.html">configService</a></li><li><a href="app.geo.module_gapiService.html">gapiService</a></li><li><a href="app.geo.module_Geo.html">Geo</a></li><li><a href="app.geo.module_geoService.html">geoService</a></li><li><a href="app.geo.module_identifyService.html">identifyService</a></li><li><a href="app.geo.module_layerRegistry.html">layerRegistry</a></li><li><a href="app.geo.module_LegendBlock.html">LegendBlock</a></li><li><a href="app.geo.module_LegendElementFactory.html">LegendElementFactory</a></li><li><a href="app.geo.module_legendService.html">legendService</a></li><li><a href="app.geo.module_locateService.html">locateService</a></li><li><a href="app.geo.module_mapService.html">mapService</a></li><li><a href="app.geo.module_mapToolService.html">mapToolService</a></li><li><a href="app.geo.module_metadataService.html">metadataService</a></li><li><a href="app.geo.module_rvInitMap.html">rvInitMap</a></li><li><a href="app.geo.module_rvOverviewToggle.html">rvOverviewToggle</a></li><li><a href="app.layout.module_animationService.html">animationService</a></li><li><a href="app.layout.module_layoutService.html">layoutService</a></li><li><a href="app.layout.module_referenceService.html">referenceService</a></li><li><a href="app.layout.module_rvShell.html">rvShell</a></li><li><a href="app.module_core.html">core</a></li><li><a href="app.module_ui.html">ui</a></li><li><a href="app.ui.module_basemapService.html">basemapService</a></li><li><a href="app.ui.module_detailService.html">detailService</a></li><li><a href="app.ui.module_errorService.html">errorService</a></li><li><a href="app.ui.module_expandImageService.html">expandImageService</a></li><li><a href="app.ui.module_ExportComponent.html">ExportComponent</a></li><li><a href="app.ui.module_exportGenerators.html">exportGenerators</a></li><li><a href="app.ui.module_ExportSize.html">ExportSize</a></li><li><a href="app.ui.module_exportSizesService.html">exportSizesService</a></li><li><a href="app.ui.module_fullScreenService.html">fullScreenService</a></li><li><a href="app.ui.module_geosearchFiltersService.html">geosearchFiltersService</a></li><li><a href="app.ui.module_geosearchService.html">geosearchService</a></li><li><a href="app.ui.module_helpService.html">helpService</a></li><li><a href="app.ui.module_highlightFilter.html">highlightFilter</a></li><li><a href="app.ui.module_layerSource.html">layerSource</a></li><li><a href="app.ui.module_mapNavigationService.html">mapNavigationService</a></li><li><a href="app.ui.module_rvAppbar.html">rvAppbar</a></li><li><a href="app.ui.module_rvBasemap.html">rvBasemap</a></li><li><a href="app.ui.module_rvBasemapItem.html">rvBasemapItem</a></li><li><a href="app.ui.module_rvContentPane.html">rvContentPane</a></li><li><a href="app.ui.module_rvDetails.html">rvDetails</a></li><li><a href="app.ui.module_rvDetailsContent.html">rvDetailsContent</a></li><li><a href="app.ui.module_rvDetailsHeader.html">rvDetailsHeader</a></li><li><a href="app.ui.module_rvDetailsRecordEsrifeature.html">rvDetailsRecordEsrifeature</a></li><li><a href="app.ui.module_rvDetailsRecordEsrifeatureItem.html">rvDetailsRecordEsrifeatureItem</a></li><li><a href="app.ui.module_rvDetailsRecordHtml.html">rvDetailsRecordHtml</a></li><li><a href="app.ui.module_rvDetailsRecordText.html">rvDetailsRecordText</a></li><li><a href="app.ui.module_rvDetectScrollbar.html">rvDetectScrollbar</a></li><li><a href="app.ui.module_rvDragula.html">rvDragula</a></li><li><a href="app.ui.module_rvExportCustomSize.html">rvExportCustomSize</a></li><li><a href="app.ui.module_rvGeosearch.html">rvGeosearch</a></li><li><a href="app.ui.module_rvGeosearchBar.html">rvGeosearchBar</a></li><li><a href="app.ui.module_rvGeosearchBottomFilters.html">rvGeosearchBottomFilters</a></li><li><a href="app.ui.module_rvGeosearchTopFilters.html">rvGeosearchTopFilters</a></li><li><a href="app.ui.module_rvHelpOverlay.html">rvHelpOverlay</a></li><li><a href="app.ui.module_rvHelpSearch.html">rvHelpSearch</a></li><li><a href="app.ui.module_rvLayerListSlider.html">rvLayerListSlider</a></li><li><a href="app.ui.module_rvLegendBlock.html">rvLegendBlock</a></li><li><a href="app.ui.module_rvLoaderFile.html">rvLoaderFile</a></li><li><a href="app.ui.module_rvLoaderMenu.html">rvLoaderMenu</a></li><li><a href="app.ui.module_rvMapnav.html">rvMapnav</a></li><li><a href="app.ui.module_rvMapnavButton.html">rvMapnavButton</a></li><li><a href="app.ui.module_rvMenuLink.html">rvMenuLink</a></li><li><a href="app.ui.module_rvMetadataContent.html">rvMetadataContent</a></li><li><a href="app.ui.module_rvMetadataPanel.html">rvMetadataPanel</a></li><li><a href="app.ui.module_rvMorph.html">rvMorph</a></li><li><a href="app.ui.module_rvPlugSlide.html">rvPlugSlide</a></li><li><a href="app.ui.module_rvReverse.html">rvReverse</a></li><li><a href="app.ui.module_rvSettings.html">rvSettings</a></li><li><a href="app.ui.module_rvSettingsContent.html">rvSettingsContent</a></li><li><a href="app.ui.module_rvSidenav.html">rvSidenav</a></li><li><a href="app.ui.module_rvStepperItem.html">rvStepperItem</a></li><li><a href="app.ui.module_rvSymbologyStack.html">rvSymbologyStack</a></li><li><a href="app.ui.module_rvTableDefault.html">rvTableDefault</a></li><li><a href="app.ui.module_rvTableDefaultMenu.html">rvTableDefaultMenu</a></li><li><a href="app.ui.module_rvTablePanel.html">rvTablePanel</a></li><li><a href="app.ui.module_rvToc.html">rvToc</a></li><li><a href="app.ui.module_rvTocEntryControl.html">rvTocEntryControl</a></li><li><a href="app.ui.module_rvTocExpandMenu.html">rvTocExpandMenu</a></li><li><a href="app.ui.module_rvTocVisibilityMenu.html">rvTocVisibilityMenu</a></li><li><a href="app.ui.module_rvToggleSlide.html">rvToggleSlide</a></li><li><a href="app.ui.module_rvTooltip.html">rvTooltip</a></li><li><a href="app.ui.module_rvTruncate.html">rvTruncate</a></li><li><a href="app.ui.module_sideNavigationService.html">sideNavigationService</a></li><li><a href="app.ui.module_StepperFactory.html">StepperFactory</a></li><li><a href="app.ui.module_SymbologyStack.html">SymbologyStack</a></li><li><a href="app.ui.module_tableService.html">tableService</a></li><li><a href="app.ui.module_tocService.html">tocService</a></li><li><a href="app.ui.module_tooltipService.html">tooltipService</a></li><li><a href="material.components.button.module_MdButtonDirectiveDecorator.html">MdButtonDirectiveDecorator</a></li><li><a href="material.components.dialog.module_$mdDialog.html">$mdDialog</a></li><li><a href="material.components.icon.module_mdIconDirectiveDecorator.html">mdIconDirectiveDecorator</a></li><li><a href="material.components.menu.module_mdMenuDirective.html">mdMenuDirective</a></li><li><a href="material.components.menu.module_mdSelectDirective.html">mdSelectDirective</a></li><li><a href="material.components.menuBar.module_mdMenuItemDirectiveDecorator.html">mdMenuItemDirectiveDecorator</a></li><li><a href="material.components.select.module_mdSelectMenuDirective.html">mdSelectMenuDirective</a></li><li><a href="material.components.tooltip.module_mdTooltipDirective.html">mdTooltipDirective</a></li></ul><h3>Namespaces</h3><ul><li><a href="app.html">app</a></li><li><a href="app.core.html">core</a></li><li><a href="app.geo.html">geo</a></li><li><a href="app.layout.html">layout</a></li><li><a href="app.ui.html">ui</a></li></ul><h3>Classes</h3><ul><li><a href="app.core.module_ConfigObject-About.html">About</a></li><li><a href="app.core.module_ConfigObject-Basemap.html">Basemap</a></li><li><a href="app.core.module_ConfigObject-ConfigObject.html">ConfigObject</a></li><li><a href="app.core.module_ConfigObject-Entry.html">Entry</a></li><li><a href="app.core.module_ConfigObject-ExportComponent.html">ExportComponent</a></li><li><a href="app.core.module_ConfigObject-ExportService.html">ExportService</a></li><li><a href="app.core.module_ConfigObject-ExtentSet.html">ExtentSet</a></li><li><a href="app.core.module_ConfigObject-Help.html">Help</a></li><li><a href="app.core.module_ConfigObject-InfoSection.html">InfoSection</a></li><li><a href="app.core.module_ConfigObject-InitialLayerSettings.html">InitialLayerSettings</a></li><li><a href="app.core.module_ConfigObject-LayerNode.html">LayerNode</a></li><li><a href="app.core.module_ConfigObject-Legend.html">Legend</a></li><li><a href="app.core.module_ConfigObject-LegendExportComponent.html">LegendExportComponent</a></li><li><a href="app.core.module_ConfigObject-LegendIsOpen.html">LegendIsOpen</a></li><li><a href="app.core.module_ConfigObject-LodSet.html">LodSet</a></li><li><a href="app.core.module_ConfigObject-Map.html">Map</a></li><li><a href="app.core.module_ConfigObject-NavBar.html">NavBar</a></li><li><a href="app.core.module_ConfigObject-Services.html">Services</a></li><li><a href="app.core.module_ConfigObject-SideMenu.html">SideMenu</a></li><li><a href="app.core.module_ConfigObject-StartPoint.html">StartPoint</a></li><li><a href="app.core.module_ConfigObject-TableIsOpen.html">TableIsOpen</a></li><li><a href="app.core.module_ConfigObject-TileSchema.html">TileSchema</a></li><li><a href="app.core.module_ConfigObject-UI.html">UI</a></li><li><a href="app.core.module_ConfigObject-UILegend.html">UILegend</a></li><li><a href="app.core.module_ConfigObject-VisibilitySet.html">VisibilitySet</a></li><li><a href="app.core.module_configService-Config.html">Config</a></li><li><a href="app.geo.module_LegendBlock-LegendGroup.html">LegendGroup</a></li><li><a href="app.geo.module_LegendBlock-ProxyWrapper.html">ProxyWrapper</a></li><li><a href="app.geo.module_LegendElementFactory-SymbologyControl.html">SymbologyControl</a></li><li><a href="app.ui.module_StepperFactory-Stepper.html">Stepper</a></li><li><a href="app.ui.module_SymbologyStack-SymbologyStack.html">SymbologyStack</a></li><li><a href="app.ui.module_tooltipService-ContainInside.html">ContainInside</a></li><li><a href="app.ui.module_tooltipService-FollowMap.html">FollowMap</a></li><li><a href="app.ui.module_tooltipService-FollowMouse.html">FollowMouse</a></li><li><a href="app.ui.module_tooltipService-Tooltip.html">Tooltip</a></li><li><a href="app.ui.module_tooltipService-TooltipStrategy.html">TooltipStrategy</a></li><li><a href="ConfigObject.UI.html">UI</a></li><li><a href="ExportSize.html">ExportSize</a></li><li><a href="ToggleSymbol.html">ToggleSymbol</a></li><li><a href="Viewer.html">Viewer</a></li><li><a href="ViewerGroup.html">ViewerGroup</a></li></ul><h3>Global</h3><ul><li><a href="global.html#$on">$on</a></li><li><a href="global.html#_cfg">_cfg</a></li><li><a href="global.html#addViewer">addViewer</a></li><li><a href="global.html#applyDefault">applyDefault</a></li><li><a href="global.html#autolink">autolink</a></li><li><a href="global.html#centerAndZoom">centerAndZoom</a></li><li><a href="global.html#changeIconFocus">changeIconFocus</a></li><li><a href="global.html#configureParser">configureParser</a></li><li><a href="global.html#createCanvas">createCanvas</a></li><li><a href="global.html#createSvg">createSvg</a></li><li><a href="global.html#dateTimeZone">dateTimeZone</a></li><li><a href="global.html#disableCommonPrototypes">disableCommonPrototypes</a></li><li><a href="global.html#elemIsFocusable">elemIsFocusable</a></li><li><a href="global.html#focus">focus</a></li><li><a href="global.html#focusableSearch">focusableSearch</a></li><li><a href="global.html#getBookmark">getBookmark</a></li><li><a href="global.html#getConfig">getConfig</a></li><li><a href="global.html#getCurrentLang">getCurrentLang</a></li><li><a href="global.html#getTextWidth">getTextWidth</a></li><li><a href="global.html#hasLink">hasLink</a></li><li><a href="global.html#imageLoader">imageLoader</a></li><li><a href="global.html#initialBookmark">initialBookmark</a></li><li><a href="global.html#isTainted">isTainted</a></li><li><a href="global.html#isValid">isValid</a></li><li><a href="global.html#lastVisibleHistoryElement">lastVisibleHistoryElement</a></li><li><a href="global.html#link">link</a></li><li><a href="global.html#mergeCanvases">mergeCanvases</a></li><li><a href="global.html#noSourceLink">noSourceLink</a></li><li><a href="global.html#onFocusin">onFocusin</a></li><li><a href="global.html#onFocusout">onFocusout</a></li><li><a href="global.html#onKeydown">onKeydown</a></li><li><a href="global.html#onKeyup">onKeyup</a></li><li><a href="global.html#onMouseDown">onMouseDown</a></li><li><a href="global.html#picture">picture</a></li><li><a href="global.html#preLoadApiBlock">preLoadApiBlock</a></li><li><a href="global.html#process">process</a></li><li><a href="global.html#projectGeometry">projectGeometry</a></li><li><a href="global.html#readyDelay">readyDelay</a></li><li><a href="global.html#resetIconFocus">resetIconFocus</a></li><li><a href="global.html#restoreSession">restoreSession</a></li><li><a href="global.html#RV">RV</a></li><li><a href="global.html#rvCrosshairs">rvCrosshairs</a></li><li><a href="global.html#rvDefaults">rvDefaults</a></li><li><a href="global.html#rvFailureImage">rvFailureImage</a></li><li><a href="global.html#rvFocus">rvFocus</a></li><li><a href="global.html#rvNorthArrow">rvNorthArrow</a></li><li><a href="global.html#rvState">rvState</a></li><li><a href="global.html#setExtent">setExtent</a></li><li><a href="global.html#setMapCursor">setMapCursor</a></li><li><a href="global.html#setSvgHref">setSvgHref</a></li><li><a href="global.html#shellService">shellService</a></li><li><a href="global.html#shiftFocus">shiftFocus</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#svgToCanvas">svgToCanvas</a></li><li><a href="global.html#uid">uid</a></li><li><a href="global.html#updateNorthArrow">updateNorthArrow</a></li><li><a href="global.html#useBookmark">useBookmark</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Wed Nov 23 2022 21:00:04 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
